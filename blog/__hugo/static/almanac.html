<!DOCTYPE html>
<!-- saved from url=(0056)https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/ -->
<html xmlns="http://www.w3.org/1999/xhtml"><!--
    This document is automatically generated.  Changes may be lost.
    Edit the corresponding Markdown file and run '~jashankj/bin/md'
    to update this file.
  --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>The Algorithms Almanack</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css">
  <style type="text/css">
@media screen { body { max-width: 80ex !important; margin-left: auto; margin-right: auto; } }
  </style>
</head>
<body class="container vsc-initialized">
<header class="page-header">
<h1 class="title">The Algorithms Almanack</h1>
</header>
<header class="page-header text-center">
<h1 id="algorithms-almanac">Algorithms Almanac</h1>
<p><strong>Linear ADTs</strong>: <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#stacks">Stack</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#queues">Queue</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#lists">List</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#priority-queues">PQueue</a><br>
<strong>Sorting</strong>: <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#insertion-sort">insertion</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#selection-sort">selection</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#bubble-sort">bubble</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#quicksort-m3">quick M3</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#merge-sort">merge</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#heap-sort">heap</a><br>
<strong>Searching</strong>: <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#binary-search-trees">BST</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#splay-tree">splay</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#avl-tree">AVL</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#234-tree">2-3-4</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#rb-tree">red-black</a><br>
<strong>Graphs</strong>: <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#graphs">interface</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#graph-adjmatrix">adj.matrix</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#graph-adjlist">adj.list</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#graph-traversal">traversal</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#directed-graphs">digraphs</a> | <a href="https://www.cse.unsw.edu.au/~cs2521/19T0/exams/almanack/#weighted-graphs">wgraphs</a></p>
</header>
<p>This document gives code for representative ADTs and algorithms discussed in COMP2521&nbsp;19t0. Itâ€™s organised as a single long page, broken down by topic area.</p>
<p>The code assumes that all collection types are made up of <code>Item</code>s, where the <code>Item</code> type has equality, less than, greater than, comparison, and display functions available as <code>eq(it1,it2)</code>, <code>less(it1,it2)</code>, <code>greater(it1,it2)</code>, <code>cmp(it1,it2)</code> and <code>show(it)</code>. Sometimes, <code>Item</code>s have keys which are integer or string values that uniquely identify the <code>Item</code>. The key value can be extracted from an <code>Item</code> using the <code>key(it)</code> function.</p>
<p>ADTs are implemented via a pointer to a hidden representation type (e.g.&nbsp;the <code>Stack</code> type is a pointer to a <code>StackRep</code> structure).</p>
<p><span class="label label-danger">WARNING!</span> The code below has not been compiled or tested; we make no guarantees that there are no bugs. This code is provided simply as a guide to how the algorithms were implemented.</p>
<h2 id="linear-adts">Linear ADTs</h2>
<h2 id="stacks">Stacks</h2>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Interface </strong>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// stack.h</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">typedef</span> <span class="kw">struct</span> StackRep *Stack;</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">Stack newStack (<span class="dt">int</span>);               <span class="co">// set up empty stack</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="dt">void</span> dropStack (Stack);             <span class="co">// remove unwanted stack</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="dt">void</span> StackPush (Stack, Item);       <span class="co">// insert an Item on top of stack</span></a>
<a class="sourceLine" id="cb1-7" title="7">Item StackPop (Stack);              <span class="co">// remove Item from top of stack</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="dt">bool</span> StackIsEmpty (Stack);          <span class="co">// check whether stack is empty</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">// EOF</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Implementation (via arrays) </strong>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#define MAXITEMS 10</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">"stack.h"</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">typedef</span> <span class="kw">struct</span> StackRep {</a>
<a class="sourceLine" id="cb2-5" title="5">    Item *item;</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="dt">int</span> top;</a>
<a class="sourceLine" id="cb2-7" title="7">} StackRep;</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">// set up empty stack</span></a>
<a class="sourceLine" id="cb2-10" title="10">Stack newStack (<span class="dt">int</span> n)</a>
<a class="sourceLine" id="cb2-11" title="11">{</a>
<a class="sourceLine" id="cb2-12" title="12">    Stack s;</a>
<a class="sourceLine" id="cb2-13" title="13">    s = malloc (<span class="kw">sizeof</span> (StackRep));</a>
<a class="sourceLine" id="cb2-14" title="14">    assert (s != NULL);</a>
<a class="sourceLine" id="cb2-15" title="15">    s-&gt;item = malloc (n * <span class="kw">sizeof</span> (Item));</a>
<a class="sourceLine" id="cb2-16" title="16">    assert (s-&gt;item != NULL);</a>
<a class="sourceLine" id="cb2-17" title="17">    s-&gt;top = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb2-18" title="18">    <span class="cf">return</span> s;</a>
<a class="sourceLine" id="cb2-19" title="19">}</a>
<a class="sourceLine" id="cb2-20" title="20"></a>
<a class="sourceLine" id="cb2-21" title="21"><span class="co">// remove unwanted stack</span></a>
<a class="sourceLine" id="cb2-22" title="22"><span class="dt">void</span> dropStack (Stack s)</a>
<a class="sourceLine" id="cb2-23" title="23">{</a>
<a class="sourceLine" id="cb2-24" title="24">    assert (s != NULL);</a>
<a class="sourceLine" id="cb2-25" title="25">    free (s-&gt;item);</a>
<a class="sourceLine" id="cb2-26" title="26">    free (s);</a>
<a class="sourceLine" id="cb2-27" title="27">}</a>
<a class="sourceLine" id="cb2-28" title="28"></a>
<a class="sourceLine" id="cb2-29" title="29"><span class="co">// insert Item on top of stack</span></a>
<a class="sourceLine" id="cb2-30" title="30"><span class="dt">void</span> StackPush (Stack s, Item it)</a>
<a class="sourceLine" id="cb2-31" title="31">{</a>
<a class="sourceLine" id="cb2-32" title="32">    assert (s-&gt;top &lt; MAXITEMS - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb2-33" title="33">    s-&gt;top++;</a>
<a class="sourceLine" id="cb2-34" title="34">    <span class="dt">int</span> i = s-&gt;top;</a>
<a class="sourceLine" id="cb2-35" title="35">    s-&gt;item[i] = it;</a>
<a class="sourceLine" id="cb2-36" title="36">}</a>
<a class="sourceLine" id="cb2-37" title="37"></a>
<a class="sourceLine" id="cb2-38" title="38"><span class="co">// remove Item from top of stack</span></a>
<a class="sourceLine" id="cb2-39" title="39">Item StackPop (Stack s)</a>
<a class="sourceLine" id="cb2-40" title="40">{</a>
<a class="sourceLine" id="cb2-41" title="41">    assert (s-&gt;top &gt; <span class="dv">-1</span>);</a>
<a class="sourceLine" id="cb2-42" title="42">    <span class="dt">int</span> i = s-&gt;top;</a>
<a class="sourceLine" id="cb2-43" title="43">    Item it = s-&gt;item[i];</a>
<a class="sourceLine" id="cb2-44" title="44">    s-&gt;top--;</a>
<a class="sourceLine" id="cb2-45" title="45">    <span class="cf">return</span> it;</a>
<a class="sourceLine" id="cb2-46" title="46">}</a>
<a class="sourceLine" id="cb2-47" title="47"></a>
<a class="sourceLine" id="cb2-48" title="48"><span class="co">// check whether stack is empty</span></a>
<a class="sourceLine" id="cb2-49" title="49"><span class="dt">bool</span> StackIsEmpty (Stack s)</a>
<a class="sourceLine" id="cb2-50" title="50">{</a>
<a class="sourceLine" id="cb2-51" title="51">    <span class="cf">return</span> (s-&gt;top &lt; <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb2-52" title="52">}</a></code></pre></div>
</div>
<h2 id="queues">Queues</h2>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Interface </strong>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// queue.h</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">typedef</span> <span class="kw">struct</span> QueueRep *Queue;</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4">Queue newQueue (<span class="dt">int</span>);               <span class="co">// set up empty queue</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="dt">void</span> dropQueue (Queue);             <span class="co">// remove unwanted queue</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="dt">void</span> QueueJoin (Queue, Item);       <span class="co">// insert Item at back of queue</span></a>
<a class="sourceLine" id="cb3-7" title="7">Item QueueLeave (Queue);            <span class="co">// remove Item from front of queue</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="dt">bool</span> QueueIsEmpty (Queue);          <span class="co">// check whether queue is empty</span></a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="co">// EOF</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Implementation (via arrays) </strong>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="pp">#include </span><span class="im">"queue.h"</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">typedef</span> <span class="kw">struct</span> QueueRep {</a>
<a class="sourceLine" id="cb4-4" title="4">    Item *item;   <span class="co">// array to hold Items</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="dt">int</span> front;  <span class="co">// next Item to be removed</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="dt">int</span> back;    <span class="co">// last Item added</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">int</span> nitems;   <span class="co">// # Items currently in queue</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="dt">int</span> maxitems; <span class="co">// size of array</span></a>
<a class="sourceLine" id="cb4-9" title="9">} QueueRep;</a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">// set up empty queue</span></a>
<a class="sourceLine" id="cb4-12" title="12">Queue newQueue (<span class="dt">int</span> n)</a>
<a class="sourceLine" id="cb4-13" title="13">{</a>
<a class="sourceLine" id="cb4-14" title="14">    Queue q = malloc (<span class="kw">sizeof</span> (QueueRep));</a>
<a class="sourceLine" id="cb4-15" title="15">    assert (q != NULL);</a>
<a class="sourceLine" id="cb4-16" title="16">    q-&gt;item = malloc (n * <span class="kw">sizeof</span> (Item));</a>
<a class="sourceLine" id="cb4-17" title="17">    assert (q-&gt;item != NULL);</a>
<a class="sourceLine" id="cb4-18" title="18">    q-&gt;front = q-&gt;back = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb4-19" title="19">    q-&gt;nitems = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb4-20" title="20">    q-&gt;maxitems = n;</a>
<a class="sourceLine" id="cb4-21" title="21">    <span class="cf">return</span> q;</a>
<a class="sourceLine" id="cb4-22" title="22">}</a>
<a class="sourceLine" id="cb4-23" title="23"></a>
<a class="sourceLine" id="cb4-24" title="24"><span class="co">// remove unwanted queue</span></a>
<a class="sourceLine" id="cb4-25" title="25"><span class="dt">void</span> dropQueue (Queue q)</a>
<a class="sourceLine" id="cb4-26" title="26">{</a>
<a class="sourceLine" id="cb4-27" title="27">    assert (q != NULL);</a>
<a class="sourceLine" id="cb4-28" title="28">    free (q-&gt;item);</a>
<a class="sourceLine" id="cb4-29" title="29">    free (q);</a>
<a class="sourceLine" id="cb4-30" title="30">}</a>
<a class="sourceLine" id="cb4-31" title="31"></a>
<a class="sourceLine" id="cb4-32" title="32"><span class="co">// insert item on top of queue</span></a>
<a class="sourceLine" id="cb4-33" title="33"><span class="dt">void</span> QueueJoin (Queue q, Item it)</a>
<a class="sourceLine" id="cb4-34" title="34">{</a>
<a class="sourceLine" id="cb4-35" title="35">    assert (q-&gt;nitems &lt; q-&gt;maxitems);</a>
<a class="sourceLine" id="cb4-36" title="36">    q-&gt;item[q-&gt;front] = it;</a>
<a class="sourceLine" id="cb4-37" title="37">    q-&gt;nitems++;</a>
<a class="sourceLine" id="cb4-38" title="38">    q-&gt;front = (q-&gt;front + <span class="dv">1</span>) % q-&gt;maxitems;</a>
<a class="sourceLine" id="cb4-39" title="39">}</a>
<a class="sourceLine" id="cb4-40" title="40"></a>
<a class="sourceLine" id="cb4-41" title="41"><span class="co">// remove item from front of queue</span></a>
<a class="sourceLine" id="cb4-42" title="42">Item QueueLeave (Queue q)</a>
<a class="sourceLine" id="cb4-43" title="43">{</a>
<a class="sourceLine" id="cb4-44" title="44">    assert (q-&gt;nitems &gt; <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb4-45" title="45">    Item it = q-&gt;item[q-&gt;back];</a>
<a class="sourceLine" id="cb4-46" title="46">    q-&gt;nitems--;</a>
<a class="sourceLine" id="cb4-47" title="47">    q-&gt;back = (q-&gt;back + <span class="dv">1</span>) % q-&gt;maxitems;</a>
<a class="sourceLine" id="cb4-48" title="48">    <span class="cf">return</span> it;</a>
<a class="sourceLine" id="cb4-49" title="49">}</a>
<a class="sourceLine" id="cb4-50" title="50"></a>
<a class="sourceLine" id="cb4-51" title="51"><span class="co">// check whether queue is empty</span></a>
<a class="sourceLine" id="cb4-52" title="52"><span class="dt">bool</span> QueueIsEmpty (Queue q)</a>
<a class="sourceLine" id="cb4-53" title="53">{</a>
<a class="sourceLine" id="cb4-54" title="54">    <span class="cf">return</span> (q-&gt;nitems == <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb4-55" title="55">}</a></code></pre></div>
</div>
<h2 id="lists">Lists</h2>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Interface </strong>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// list.h</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">typedef</span> <span class="kw">struct</span> ListRep *List;</a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co">// create new, empty List</span></a>
<a class="sourceLine" id="cb5-5" title="5">List newList (<span class="dt">void</span>);</a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">// destroy a List</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="dt">void</span> freeList (List);</a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">// display as one Item per line</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="dt">void</span> showList (List);               </a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">// append one Item to List</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="dt">void</span> ListInsert (List, Item);</a>
<a class="sourceLine" id="cb5-12" title="12"><span class="co">// delete first occurrence of Item from List;</span></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co">// if Item does not occur in List, no effect</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="dt">void</span> ListDelete (List, Item);</a>
<a class="sourceLine" id="cb5-15" title="15"><span class="co">// return number of elements in a list</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="dt">int</span> ListLength(List);</a>
<a class="sourceLine" id="cb5-17" title="17"></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co">// EOF</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Implementation (via linked list) </strong>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="pp">#include </span><span class="im">"list.h"</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">typedef</span> <span class="kw">struct</span> ListNode {</a>
<a class="sourceLine" id="cb6-4" title="4">   <span class="dt">int</span>  data;  <span class="co">// value of this list item</span></a>
<a class="sourceLine" id="cb6-5" title="5">   <span class="kw">struct</span> ListNode *next;</a>
<a class="sourceLine" id="cb6-6" title="6">               <span class="co">// pointer to node containing next element</span></a>
<a class="sourceLine" id="cb6-7" title="7">} ListNode;</a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">typedef</span> <span class="kw">struct</span> ListRep {</a>
<a class="sourceLine" id="cb6-9" title="9">   <span class="dt">int</span>  size;  <span class="co">// number of elements in list</span></a>
<a class="sourceLine" id="cb6-10" title="10">   ListNode *first;  <span class="co">// node containing first value</span></a>
<a class="sourceLine" id="cb6-11" title="11">   ListNode *last;  <span class="co">// node containing last value</span></a>
<a class="sourceLine" id="cb6-12" title="12">} ListRep;</a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="co">// create a new empty List</span></a>
<a class="sourceLine" id="cb6-15" title="15">List newList (<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb6-16" title="16">{</a>
<a class="sourceLine" id="cb6-17" title="17">    ListRep *L;</a>
<a class="sourceLine" id="cb6-18" title="18">    L = malloc (<span class="kw">sizeof</span> (ListRep));</a>
<a class="sourceLine" id="cb6-19" title="19">    assert (L != NULL);</a>
<a class="sourceLine" id="cb6-20" title="20">    L-&gt;size = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-21" title="21">    L-&gt;first = NULL;</a>
<a class="sourceLine" id="cb6-22" title="22">    L-&gt;last = NULL;</a>
<a class="sourceLine" id="cb6-23" title="23">    <span class="cf">return</span> L;</a>
<a class="sourceLine" id="cb6-24" title="24">}</a>
<a class="sourceLine" id="cb6-25" title="25"></a>
<a class="sourceLine" id="cb6-26" title="26"><span class="co">// free up all space associated with list</span></a>
<a class="sourceLine" id="cb6-27" title="27"><span class="dt">void</span> freeList (List L)</a>
<a class="sourceLine" id="cb6-28" title="28">{</a>
<a class="sourceLine" id="cb6-29" title="29">    ListNode *curr, *next;</a>
<a class="sourceLine" id="cb6-30" title="30">    assert (L != NULL);</a>
<a class="sourceLine" id="cb6-31" title="31">    curr = L-&gt;first;</a>
<a class="sourceLine" id="cb6-32" title="32">    <span class="cf">while</span> (curr != NULL) {</a>
<a class="sourceLine" id="cb6-33" title="33">        next = curr-&gt;next;</a>
<a class="sourceLine" id="cb6-34" title="34">        free (curr);</a>
<a class="sourceLine" id="cb6-35" title="35">        curr = next;</a>
<a class="sourceLine" id="cb6-36" title="36">    }</a>
<a class="sourceLine" id="cb6-37" title="37">    free (L);</a>
<a class="sourceLine" id="cb6-38" title="38">}</a>
<a class="sourceLine" id="cb6-39" title="39"></a>
<a class="sourceLine" id="cb6-40" title="40"><span class="co">// display list as one integer per line on stdout</span></a>
<a class="sourceLine" id="cb6-41" title="41"><span class="dt">void</span> showList (List L)</a>
<a class="sourceLine" id="cb6-42" title="42">{</a>
<a class="sourceLine" id="cb6-43" title="43">    ListNode *curr;</a>
<a class="sourceLine" id="cb6-44" title="44">    curr = L-&gt;first;</a>
<a class="sourceLine" id="cb6-45" title="45">    <span class="cf">while</span> (curr != NULL) {</a>
<a class="sourceLine" id="cb6-46" title="46">        show (curr-&gt;data);</a>
<a class="sourceLine" id="cb6-47" title="47">        printf (<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>);</a>
<a class="sourceLine" id="cb6-48" title="48">        curr = curr-&gt;next;</a>
<a class="sourceLine" id="cb6-49" title="49">    }</a>
<a class="sourceLine" id="cb6-50" title="50">}</a>
<a class="sourceLine" id="cb6-51" title="51"></a>
<a class="sourceLine" id="cb6-52" title="52"><span class="co">// create a new ListNode with value it</span></a>
<a class="sourceLine" id="cb6-53" title="53"><span class="co">// (this function is local to this ADT)</span></a>
<a class="sourceLine" id="cb6-54" title="54"><span class="dt">static</span> ListNode *newListNode (Item it)</a>
<a class="sourceLine" id="cb6-55" title="55">{</a>
<a class="sourceLine" id="cb6-56" title="56">    ListNode *n;</a>
<a class="sourceLine" id="cb6-57" title="57">    n = malloc (<span class="kw">sizeof</span> (ListNode));</a>
<a class="sourceLine" id="cb6-58" title="58">    assert (n != NULL);</a>
<a class="sourceLine" id="cb6-59" title="59">    n-&gt;data = it;</a>
<a class="sourceLine" id="cb6-60" title="60">    n-&gt;next = NULL;</a>
<a class="sourceLine" id="cb6-61" title="61">    <span class="cf">return</span> n;</a>
<a class="sourceLine" id="cb6-62" title="62">}</a>
<a class="sourceLine" id="cb6-63" title="63"></a>
<a class="sourceLine" id="cb6-64" title="64"><span class="co">// apppend one Item to the end of a list</span></a>
<a class="sourceLine" id="cb6-65" title="65"><span class="dt">void</span> ListInsert (List L, Item it)</a>
<a class="sourceLine" id="cb6-66" title="66">{</a>
<a class="sourceLine" id="cb6-67" title="67">    assert (L != NULL);</a>
<a class="sourceLine" id="cb6-68" title="68">    ListNode *n;</a>
<a class="sourceLine" id="cb6-69" title="69">    n = newListNode (it);</a>
<a class="sourceLine" id="cb6-70" title="70">    <span class="cf">if</span> (L-&gt;first == NULL)</a>
<a class="sourceLine" id="cb6-71" title="71">        L-&gt;first = L-&gt;last = n;</a>
<a class="sourceLine" id="cb6-72" title="72">    <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb6-73" title="73">        L-&gt;last-&gt;next = n;</a>
<a class="sourceLine" id="cb6-74" title="74">        L-&gt;last = n;</a>
<a class="sourceLine" id="cb6-75" title="75">    }</a>
<a class="sourceLine" id="cb6-76" title="76">    L-&gt;size++;</a>
<a class="sourceLine" id="cb6-77" title="77">}</a>
<a class="sourceLine" id="cb6-78" title="78"></a>
<a class="sourceLine" id="cb6-79" title="79"><span class="co">// remove an item from a List</span></a>
<a class="sourceLine" id="cb6-80" title="80"><span class="dt">void</span> ListDelete (List L, Item it)</a>
<a class="sourceLine" id="cb6-81" title="81">{</a>
<a class="sourceLine" id="cb6-82" title="82">    assert (L != NULL);</a>
<a class="sourceLine" id="cb6-83" title="83">    ListNode *curr, *prev;</a>
<a class="sourceLine" id="cb6-84" title="84">    prev = NULL;</a>
<a class="sourceLine" id="cb6-85" title="85">    curr = L-&gt;first;</a>
<a class="sourceLine" id="cb6-86" title="86">    <span class="cf">while</span> (curr != NULL &amp;&amp; !eq (curr-&gt;data, it)) {</a>
<a class="sourceLine" id="cb6-87" title="87">        prev = curr;</a>
<a class="sourceLine" id="cb6-88" title="88">        curr = curr-&gt;next;</a>
<a class="sourceLine" id="cb6-89" title="89">    }</a>
<a class="sourceLine" id="cb6-90" title="90">    <span class="cf">if</span> (curr == NULL)</a>
<a class="sourceLine" id="cb6-91" title="91">        <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb6-92" title="92">    <span class="cf">if</span> (prev == NULL)</a>
<a class="sourceLine" id="cb6-93" title="93">        L-&gt;first = curr-&gt;next;</a>
<a class="sourceLine" id="cb6-94" title="94">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb6-95" title="95">        prev-&gt;next = curr-&gt;next;</a>
<a class="sourceLine" id="cb6-96" title="96">    <span class="cf">if</span> (L-&gt;last == curr)</a>
<a class="sourceLine" id="cb6-97" title="97">        L-&gt;last = prev;</a>
<a class="sourceLine" id="cb6-98" title="98">    L-&gt;size--;</a>
<a class="sourceLine" id="cb6-99" title="99">    free (curr);</a>
<a class="sourceLine" id="cb6-100" title="100">}</a>
<a class="sourceLine" id="cb6-101" title="101"></a>
<a class="sourceLine" id="cb6-102" title="102"><span class="co">// return number of elements in a list</span></a>
<a class="sourceLine" id="cb6-103" title="103"><span class="dt">int</span> ListLength (List L)</a>
<a class="sourceLine" id="cb6-104" title="104">{</a>
<a class="sourceLine" id="cb6-105" title="105">    assert (L != NULL);</a>
<a class="sourceLine" id="cb6-106" title="106">    <span class="cf">return</span> L-&gt;size;</a>
<a class="sourceLine" id="cb6-107" title="107">}</a></code></pre></div>
</div>
<h2 id="priority-queues">Priority Queues</h2>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Interface </strong>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="co">// pqueue.h</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">typedef</span> <span class="kw">struct</span> PQueueRep *PQueue;</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="co">// create new empty priority queue</span></a>
<a class="sourceLine" id="cb7-5" title="5">PQueue newPQueue(<span class="dt">int</span> size);</a>
<a class="sourceLine" id="cb7-6" title="6"><span class="co">// add item to priority queue</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="dt">void</span> PQJoin(PQueue q, Item it);</a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">// remove item from priority queue</span></a>
<a class="sourceLine" id="cb7-9" title="9">Item PQLeave(PQueue q);</a>
<a class="sourceLine" id="cb7-10" title="10"><span class="co">// free up priority queue</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="dt">void</span> dropPQueue(PQueue q);</a>
<a class="sourceLine" id="cb7-12" title="12"></a>
<a class="sourceLine" id="cb7-13" title="13"><span class="co">// EOF</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Implementation (via heap-array) </strong>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// pqueue_heaparray.c</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="pp">#include </span><span class="im">"pqueue.h"</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="dt">static</span> <span class="dt">void</span> fixUp (Item a[], <span class="dt">int</span> k);</a>
<a class="sourceLine" id="cb8-6" title="6"><span class="dt">static</span> <span class="dt">void</span> fixDown (Item a[], <span class="dt">int</span> k, <span class="dt">int</span> N);</a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="kw">struct</span> PQueueRep {</a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="dt">int</span> nItems;  <span class="co">// count of items</span></a>
<a class="sourceLine" id="cb8-10" title="10">    Item *items; <span class="co">// heap-array of Items</span></a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="dt">int</span> size;   <span class="co">// size of array</span></a>
<a class="sourceLine" id="cb8-12" title="12">};</a>
<a class="sourceLine" id="cb8-13" title="13"></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="co">// create a new empty queue</span></a>
<a class="sourceLine" id="cb8-15" title="15">PQueue newPQueue (<span class="dt">int</span> size)</a>
<a class="sourceLine" id="cb8-16" title="16">{</a>
<a class="sourceLine" id="cb8-17" title="17">    PQueue q = malloc (<span class="kw">sizeof</span> (<span class="kw">struct</span> PQueueRep));</a>
<a class="sourceLine" id="cb8-18" title="18">    assert (q != NULL);</a>
<a class="sourceLine" id="cb8-19" title="19">    <span class="co">// indexes start from 1</span></a>
<a class="sourceLine" id="cb8-20" title="20">    q-&gt;items = malloc (<span class="kw">sizeof</span> (Item) * (size + <span class="dv">1</span>));</a>
<a class="sourceLine" id="cb8-21" title="21">    assert (q-&gt;items != NULL);</a>
<a class="sourceLine" id="cb8-22" title="22">    q-&gt;nItems = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb8-23" title="23">    q-&gt;size = size;</a>
<a class="sourceLine" id="cb8-24" title="24">    <span class="cf">return</span> q;</a>
<a class="sourceLine" id="cb8-25" title="25">}</a>
<a class="sourceLine" id="cb8-26" title="26"></a>
<a class="sourceLine" id="cb8-27" title="27"><span class="co">// add a new item into the queue</span></a>
<a class="sourceLine" id="cb8-28" title="28"><span class="dt">void</span></a>
<a class="sourceLine" id="cb8-29" title="29">PQJoin (PQueue q, Item it)</a>
<a class="sourceLine" id="cb8-30" title="30">{</a>
<a class="sourceLine" id="cb8-31" title="31">    assert (q != NULL &amp;&amp; q-&gt;nItems &lt; q-&gt;size);</a>
<a class="sourceLine" id="cb8-32" title="32">    q-&gt;nItems++;</a>
<a class="sourceLine" id="cb8-33" title="33">    q-&gt;items[q-&gt;nItems] = it;</a>
<a class="sourceLine" id="cb8-34" title="34">    fixUp (q-&gt;items, q-&gt;nItems);</a>
<a class="sourceLine" id="cb8-35" title="35">}</a>
<a class="sourceLine" id="cb8-36" title="36"></a>
<a class="sourceLine" id="cb8-37" title="37"><span class="co">// remove item from priority queue</span></a>
<a class="sourceLine" id="cb8-38" title="38">Item</a>
<a class="sourceLine" id="cb8-39" title="39">PQLeave (PQueue q)</a>
<a class="sourceLine" id="cb8-40" title="40">{</a>
<a class="sourceLine" id="cb8-41" title="41">    assert (q != NULL &amp;&amp; q-&gt;nItems &gt; <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb8-42" title="42">    swap (q-&gt;items, <span class="dv">1</span>, q-&gt;nItems);</a>
<a class="sourceLine" id="cb8-43" title="43">    q-&gt;nItems--;</a>
<a class="sourceLine" id="cb8-44" title="44">    fixDown (q-&gt;items, <span class="dv">1</span>, q-&gt;nItems);</a>
<a class="sourceLine" id="cb8-45" title="45">    <span class="cf">return</span> q-&gt;items[q-&gt;nItems + <span class="dv">1</span>];</a>
<a class="sourceLine" id="cb8-46" title="46">}</a>
<a class="sourceLine" id="cb8-47" title="47"></a>
<a class="sourceLine" id="cb8-48" title="48"><span class="co">// free up priority queue</span></a>
<a class="sourceLine" id="cb8-49" title="49"><span class="dt">void</span> dropPQueue (PQueue q)</a>
<a class="sourceLine" id="cb8-50" title="50">{</a>
<a class="sourceLine" id="cb8-51" title="51">    assert (q != NULL);</a>
<a class="sourceLine" id="cb8-52" title="52">    free (q-&gt;items);</a>
<a class="sourceLine" id="cb8-53" title="53">    free (q);</a>
<a class="sourceLine" id="cb8-54" title="54">}</a>
<a class="sourceLine" id="cb8-55" title="55"></a>
<a class="sourceLine" id="cb8-56" title="56"><span class="dt">static</span> <span class="dt">void</span> fixUp (Item a[], <span class="dt">int</span> k)</a>
<a class="sourceLine" id="cb8-57" title="57">{</a>
<a class="sourceLine" id="cb8-58" title="58">    <span class="cf">while</span> (k &gt; <span class="dv">1</span> &amp;&amp; less (a[k / <span class="dv">2</span>], a[k])) {</a>
<a class="sourceLine" id="cb8-59" title="59">        swap (a, k, k / <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb8-60" title="60">        k = k / <span class="dv">2</span>; <span class="co">// integer division</span></a>
<a class="sourceLine" id="cb8-61" title="61">    }</a>
<a class="sourceLine" id="cb8-62" title="62">}</a>
<a class="sourceLine" id="cb8-63" title="63"></a>
<a class="sourceLine" id="cb8-64" title="64"><span class="dt">static</span> <span class="dt">void</span> fixDown (Item a[], <span class="dt">int</span> k, <span class="dt">int</span> N)</a>
<a class="sourceLine" id="cb8-65" title="65">{</a>
<a class="sourceLine" id="cb8-66" title="66">    <span class="cf">while</span> (<span class="dv">2</span> * k &lt;= N) {</a>
<a class="sourceLine" id="cb8-67" title="67">        <span class="dt">int</span> j = <span class="dv">2</span> * k;</a>
<a class="sourceLine" id="cb8-68" title="68">        <span class="co">// choose larger of two children</span></a>
<a class="sourceLine" id="cb8-69" title="69">        <span class="cf">if</span> (j &lt; N &amp;&amp; less (a[j], a[j + <span class="dv">1</span>]))</a>
<a class="sourceLine" id="cb8-70" title="70">            j++;</a>
<a class="sourceLine" id="cb8-71" title="71">        <span class="cf">if</span> (!less (a[k], a[j]))</a>
<a class="sourceLine" id="cb8-72" title="72">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb8-73" title="73">        swap (a, k, j);</a>
<a class="sourceLine" id="cb8-74" title="74">        k = j;</a>
<a class="sourceLine" id="cb8-75" title="75">    }</a>
<a class="sourceLine" id="cb8-76" title="76">}</a></code></pre></div>
</div>
<h2 id="sorting">Sorting</h2>
<p>The sorting problem:</p>
<pre><code>Pre-condition: a[0..N-1] contain Items
Post-condition: forall i:0..N-2,  key(a[i]) &amp;leq; key(a[i+1])

Stability: consider item1 and item2 where key(item1) == key(item2)
if, before sorting, item1 is a[i] &amp;&amp; item2 is a[j] &amp;&amp; i &lt; j
then, after sorting, item1 is a[m] &amp;&amp; item2 is a[n] &amp;&amp; m &lt; n</code></pre>
<div class="panel panel-default">
<div id="insertion-sort" class="panel-heading">
<strong> Insertion Sort </strong>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="co">// sort_insertion.c</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="dt">void</span> insertionSort (<span class="dt">int</span> a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb10-4" title="4">{</a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="dt">int</span> i, j, val;</a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="cf">for</span> (i = lo + <span class="dv">1</span>; i &lt;= hi; i++) {</a>
<a class="sourceLine" id="cb10-7" title="7">        val = a[i];</a>
<a class="sourceLine" id="cb10-8" title="8">        <span class="cf">for</span> (j = i; j &gt; lo; j--) {</a>
<a class="sourceLine" id="cb10-9" title="9">            <span class="cf">if</span> (!less (val, a[j - <span class="dv">1</span>]))</a>
<a class="sourceLine" id="cb10-10" title="10">                <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb10-11" title="11">            a[j] = a[j - <span class="dv">1</span>];</a>
<a class="sourceLine" id="cb10-12" title="12">        }</a>
<a class="sourceLine" id="cb10-13" title="13">        a[j] = val;</a>
<a class="sourceLine" id="cb10-14" title="14">    }</a>
<a class="sourceLine" id="cb10-15" title="15">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="selection-sort" class="panel-heading">
<strong> Selection Sort </strong>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="co">// sort_selection.c</span></a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="dt">void</span> selectionSort (<span class="dt">int</span> a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb11-4" title="4">{</a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="dt">int</span> i, j, min;</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="cf">for</span> (i = lo; i &lt; hi; i++) {</a>
<a class="sourceLine" id="cb11-7" title="7">        min = i;</a>
<a class="sourceLine" id="cb11-8" title="8">        <span class="cf">for</span> (j = i + <span class="dv">1</span>; j &lt;= hi; j++) {</a>
<a class="sourceLine" id="cb11-9" title="9">            <span class="cf">if</span> (less (a[j], a[min]))</a>
<a class="sourceLine" id="cb11-10" title="10">                min = j;</a>
<a class="sourceLine" id="cb11-11" title="11">        }</a>
<a class="sourceLine" id="cb11-12" title="12">        swap (&amp;a[i], &amp;a[min]);</a>
<a class="sourceLine" id="cb11-13" title="13">    }</a>
<a class="sourceLine" id="cb11-14" title="14">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="bubble-sort" class="panel-heading">
<strong> Bubble Sort </strong>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="co">// sort_bubble.c</span></a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="dt">void</span> bubbleSort (<span class="dt">int</span> a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb12-4" title="4">{</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="dt">int</span> i, j, nswaps;</a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="cf">for</span> (i = lo; i &lt; hi; i++) {</a>
<a class="sourceLine" id="cb12-7" title="7">        nswaps = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb12-8" title="8">        <span class="cf">for</span> (j = hi; j &gt; i; j--) {</a>
<a class="sourceLine" id="cb12-9" title="9">            <span class="cf">if</span> (less (a[j], a[j - <span class="dv">1</span>])) {</a>
<a class="sourceLine" id="cb12-10" title="10">                swap (&amp;a[j], &amp;a[j - <span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb12-11" title="11">                nswaps++;</a>
<a class="sourceLine" id="cb12-12" title="12">            }</a>
<a class="sourceLine" id="cb12-13" title="13">        }</a>
<a class="sourceLine" id="cb12-14" title="14">        <span class="cf">if</span> (nswaps == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb12-15" title="15">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb12-16" title="16">    }</a>
<a class="sourceLine" id="cb12-17" title="17">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="quicksort-m3" class="panel-heading">
<strong> Quicksort (median-of-three partitioning) </strong>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// sort_qsort_m3.c</span></a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="dt">void</span> quicksort (Item a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb13-4" title="4">{</a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="dt">int</span> i; <span class="co">// index of pivot</span></a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="cf">if</span> (hi &lt;= lo) <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb13-7" title="7">    medianOfThree (a, lo, hi);</a>
<a class="sourceLine" id="cb13-8" title="8">    i = partition (a, lo + <span class="dv">1</span>, hi - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-9" title="9">    quicksort (a, lo, i - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb13-10" title="10">    quicksort (a, i + <span class="dv">1</span>, hi);</a>
<a class="sourceLine" id="cb13-11" title="11">}</a>
<a class="sourceLine" id="cb13-12" title="12"></a>
<a class="sourceLine" id="cb13-13" title="13"><span class="dt">void</span> medianOfThree (Item a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb13-14" title="14">{</a>
<a class="sourceLine" id="cb13-15" title="15">    <span class="dt">int</span> mid = (lo + hi) / <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb13-16" title="16">    <span class="cf">if</span> (less (a[mid], a[lo])) swap (a, lo, mid);</a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="cf">if</span> (less (a[hi], a[mid])) swap (a, mid, hi);</a>
<a class="sourceLine" id="cb13-18" title="18">    <span class="cf">if</span> (less (a[mid], a[lo])) swap (a, lo, mid);</a>
<a class="sourceLine" id="cb13-19" title="19">    <span class="co">// now, we have a[lo] â‰¤ a[mid] â‰¤ a[hi]</span></a>
<a class="sourceLine" id="cb13-20" title="20">    <span class="co">// swap a[mid] to a[lo+1] to use as pivot</span></a>
<a class="sourceLine" id="cb13-21" title="21">    swap (a, lo + <span class="dv">1</span>, mid);</a>
<a class="sourceLine" id="cb13-22" title="22">}</a>
<a class="sourceLine" id="cb13-23" title="23"></a>
<a class="sourceLine" id="cb13-24" title="24"><span class="dt">int</span> partition (Item a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb13-25" title="25">{</a>
<a class="sourceLine" id="cb13-26" title="26">    Item v = a[lo]; <span class="co">// pivot</span></a>
<a class="sourceLine" id="cb13-27" title="27">    <span class="dt">int</span> i = lo + <span class="dv">1</span>, j = hi;</a>
<a class="sourceLine" id="cb13-28" title="28">    <span class="cf">for</span> (;;) {</a>
<a class="sourceLine" id="cb13-29" title="29">        <span class="cf">while</span> (less (a[i], v) &amp;&amp; i &lt; j) i++;</a>
<a class="sourceLine" id="cb13-30" title="30">        <span class="cf">while</span> (less (v, a[j]) &amp;&amp; j &gt; i) j--;</a>
<a class="sourceLine" id="cb13-31" title="31">        <span class="cf">if</span> (i == j) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb13-32" title="32">        swap (a, i, j);</a>
<a class="sourceLine" id="cb13-33" title="33">    }</a>
<a class="sourceLine" id="cb13-34" title="34">    j = less (a[i], v) ? i : i - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb13-35" title="35">    swap (a, lo, j);</a>
<a class="sourceLine" id="cb13-36" title="36">    <span class="cf">return</span> j;</a>
<a class="sourceLine" id="cb13-37" title="37">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="merge-sort" class="panel-heading">
<strong> Mergesort </strong>
</div>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// sort_merge.c</span></a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="dt">void</span> mergesort (Item a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb14-4" title="4">{</a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="dt">int</span> mid = (lo + hi) / <span class="dv">2</span>; <span class="co">// mid point</span></a>
<a class="sourceLine" id="cb14-6" title="6">    <span class="cf">if</span> (hi &lt;= lo)</a>
<a class="sourceLine" id="cb14-7" title="7">        <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb14-8" title="8">    mergesort (a, lo, mid);</a>
<a class="sourceLine" id="cb14-9" title="9">    mergesort (a, mid + <span class="dv">1</span>, hi);</a>
<a class="sourceLine" id="cb14-10" title="10">    merge (a, lo, mid, hi);</a>
<a class="sourceLine" id="cb14-11" title="11">}</a>
<a class="sourceLine" id="cb14-12" title="12"></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="dt">static</span> <span class="dt">void</span> merge (Item a[], <span class="dt">int</span> lo, <span class="dt">int</span> mid, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb14-14" title="14">{</a>
<a class="sourceLine" id="cb14-15" title="15">    <span class="dt">int</span> nitems = hi - lo + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb14-16" title="16">    Item *tmp = malloc (nitems * <span class="kw">sizeof</span> (Item));</a>
<a class="sourceLine" id="cb14-17" title="17"></a>
<a class="sourceLine" id="cb14-18" title="18">    <span class="co">// scan both segments, copying to tmp</span></a>
<a class="sourceLine" id="cb14-19" title="19">    <span class="dt">int</span> i = lo, j = mid + <span class="dv">1</span>, k = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-20" title="20">    <span class="cf">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) {</a>
<a class="sourceLine" id="cb14-21" title="21">        <span class="cf">if</span> (less (a[i], a[j]))</a>
<a class="sourceLine" id="cb14-22" title="22">            tmp[k++] = a[i++];</a>
<a class="sourceLine" id="cb14-23" title="23">        <span class="cf">else</span></a>
<a class="sourceLine" id="cb14-24" title="24">            tmp[k++] = a[j++];</a>
<a class="sourceLine" id="cb14-25" title="25">    }</a>
<a class="sourceLine" id="cb14-26" title="26"></a>
<a class="sourceLine" id="cb14-27" title="27">    <span class="co">// copy items from unfinished segment</span></a>
<a class="sourceLine" id="cb14-28" title="28">    <span class="cf">while</span> (i &lt;= mid) tmp[k++] = a[i++];</a>
<a class="sourceLine" id="cb14-29" title="29">    <span class="cf">while</span> (j &lt;= hi)  tmp[k++] = a[j++];</a>
<a class="sourceLine" id="cb14-30" title="30"></a>
<a class="sourceLine" id="cb14-31" title="31">    <span class="co">// copy tmp back to main array</span></a>
<a class="sourceLine" id="cb14-32" title="32">    <span class="cf">for</span> (i = lo, k = <span class="dv">0</span>; i &lt;= hi; i++, k++)</a>
<a class="sourceLine" id="cb14-33" title="33">        a[i] = tmp[k];</a>
<a class="sourceLine" id="cb14-34" title="34"></a>
<a class="sourceLine" id="cb14-35" title="35">    free (tmp);</a>
<a class="sourceLine" id="cb14-36" title="36">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="heap-sort" class="panel-heading">
<strong> Heapsort (requires PQueue) </strong>
</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="co">// sort_heap.c</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="pp">#include </span><span class="im">"pqueue.h"</span></a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="co">// Brute-force heapsort.</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="dt">void</span> HeapSort (Item a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb15-6" title="6">{</a>
<a class="sourceLine" id="cb15-7" title="7">    PQueue pq = newPQueue (hi - lo + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb15-8" title="8">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb15-9" title="9">    <span class="cf">for</span> (i = lo; i &lt;= hi; i++) {</a>
<a class="sourceLine" id="cb15-10" title="10">        PQJoin (pq, a[i]);</a>
<a class="sourceLine" id="cb15-11" title="11">    }</a>
<a class="sourceLine" id="cb15-12" title="12">    <span class="cf">for</span> (i = hi; i &gt;= lo; i--) {</a>
<a class="sourceLine" id="cb15-13" title="13">        Item it = PQLeave (pq);</a>
<a class="sourceLine" id="cb15-14" title="14">        a[i] = it;</a>
<a class="sourceLine" id="cb15-15" title="15">    }</a>
<a class="sourceLine" id="cb15-16" title="16">}</a></code></pre></div>
</div>
<h2 id="searching">Searching</h2>
<div class="panel panel-default">
<div id="bsearch-array" class="panel-heading">
<strong> Binary Search in Array </strong>
</div>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="co">// bsearch_array.c</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">// search for key k in array a[]</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="co">// - returns index of location for k</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="co">// - doesn't indicate whether key is actually there or not</span></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="dt">int</span> findInArray (Item k, Item a[], <span class="dt">int</span> lo, <span class="dt">int</span> hi)</a>
<a class="sourceLine" id="cb16-7" title="7">{</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="cf">if</span> (hi &lt;= lo)</a>
<a class="sourceLine" id="cb16-9" title="9">        <span class="cf">return</span> lo;</a>
<a class="sourceLine" id="cb16-10" title="10">    <span class="dt">int</span> mid = (hi + lo) / <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb16-11" title="11">    <span class="dt">int</span> diff = cmp (k, key (a[mid]));</a>
<a class="sourceLine" id="cb16-12" title="12">    <span class="cf">if</span> (diff &lt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb16-13" title="13">        <span class="cf">return</span> findInArray (k, a, lo, mid);</a>
<a class="sourceLine" id="cb16-14" title="14">    <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb16-15" title="15">        <span class="cf">return</span> findInArray (k, a, mid + <span class="dv">1</span>, hi);</a>
<a class="sourceLine" id="cb16-16" title="16">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb16-17" title="17">        <span class="cf">return</span> mid;</a>
<a class="sourceLine" id="cb16-18" title="18">}</a></code></pre></div>
</div>
<h2 id="binary-search-trees">Binary Search Trees</h2>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Interface </strong>
</div>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// tree.h</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="kw">typedef</span> <span class="kw">struct</span> Node *Tree;</a>
<a class="sourceLine" id="cb17-4" title="4"></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="co">// create an empty Tree</span></a>
<a class="sourceLine" id="cb17-6" title="6">Tree newTree();</a>
<a class="sourceLine" id="cb17-7" title="7"><span class="co">// free memory associated with Tree</span></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="dt">void</span> dropTree(Tree);</a>
<a class="sourceLine" id="cb17-9" title="9"><span class="co">// display a Tree (sideways)</span></a>
<a class="sourceLine" id="cb17-10" title="10"><span class="dt">void</span> showTree(Tree);</a>
<a class="sourceLine" id="cb17-11" title="11"><span class="co">// insert a new item into a Tree</span></a>
<a class="sourceLine" id="cb17-12" title="12">Tree TreeInsert(Tree, Item);</a>
<a class="sourceLine" id="cb17-13" title="13">Tree TreeInsertAtRoot(Tree, Item);</a>
<a class="sourceLine" id="cb17-14" title="14">Tree TreeInsertRandom(Tree, Item);</a>
<a class="sourceLine" id="cb17-15" title="15"><span class="co">// delete item with given key from Tree</span></a>
<a class="sourceLine" id="cb17-16" title="16">Tree TreeDelete(Tree, Key);</a>
<a class="sourceLine" id="cb17-17" title="17"><span class="co">// check whether item with given key is in Tree</span></a>
<a class="sourceLine" id="cb17-18" title="18"><span class="dt">int</span> TreeFind(Tree, Key);</a>
<a class="sourceLine" id="cb17-19" title="19"><span class="co">// compute depth of Tree</span></a>
<a class="sourceLine" id="cb17-20" title="20"><span class="dt">int</span> TreeDepth(Tree);</a>
<a class="sourceLine" id="cb17-21" title="21"><span class="co">// count #nodes in Tree</span></a>
<a class="sourceLine" id="cb17-22" title="22"><span class="dt">int</span> TreeNumNodes(Tree);</a>
<a class="sourceLine" id="cb17-23" title="23"><span class="co">// fetch i'th (from left) item from Tree</span></a>
<a class="sourceLine" id="cb17-24" title="24">Item *get_ith(Tree, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb17-25" title="25"><span class="co">// partition Tree around i'th Item</span></a>
<a class="sourceLine" id="cb17-26" title="26">Tree partition(Tree, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb17-27" title="27"><span class="co">// rotate Tree left/right around root</span></a>
<a class="sourceLine" id="cb17-28" title="28">Tree rotateR(Tree);</a>
<a class="sourceLine" id="cb17-29" title="29">Tree rotateL(Tree);</a>
<a class="sourceLine" id="cb17-30" title="30"></a>
<a class="sourceLine" id="cb17-31" title="31"><span class="co">// EOF</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Implementation </strong>
</div>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="pp">#include </span><span class="im">"tree.h"</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="dt">int</span> size(Tree);</a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="kw">typedef</span> <span class="kw">struct</span> Node *Link;</a>
<a class="sourceLine" id="cb18-5" title="5"><span class="kw">typedef</span> <span class="kw">struct</span> Node {</a>
<a class="sourceLine" id="cb18-6" title="6">    Item value;</a>
<a class="sourceLine" id="cb18-7" title="7">    <span class="dt">int</span> nnodes;</a>
<a class="sourceLine" id="cb18-8" title="8">    Link left, right;</a>
<a class="sourceLine" id="cb18-9" title="9">} Node;</a>
<a class="sourceLine" id="cb18-10" title="10"></a>
<a class="sourceLine" id="cb18-11" title="11"><span class="co">// make a new node containing an Item</span></a>
<a class="sourceLine" id="cb18-12" title="12"><span class="dt">static</span> Link newNode (Item it)</a>
<a class="sourceLine" id="cb18-13" title="13">{</a>
<a class="sourceLine" id="cb18-14" title="14">    Link new = malloc (<span class="kw">sizeof</span> (Node));</a>
<a class="sourceLine" id="cb18-15" title="15">    assert (new != NULL);</a>
<a class="sourceLine" id="cb18-16" title="16">    new-&gt;value = it;</a>
<a class="sourceLine" id="cb18-17" title="17">    new-&gt;left = new-&gt;right = NULL;</a>
<a class="sourceLine" id="cb18-18" title="18">    <span class="cf">return</span> new;</a>
<a class="sourceLine" id="cb18-19" title="19">}</a>
<a class="sourceLine" id="cb18-20" title="20"></a>
<a class="sourceLine" id="cb18-21" title="21"><span class="co">// create a new empty Tree</span></a>
<a class="sourceLine" id="cb18-22" title="22">Tree newTree ()</a>
<a class="sourceLine" id="cb18-23" title="23">{</a>
<a class="sourceLine" id="cb18-24" title="24">    <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb18-25" title="25">}</a>
<a class="sourceLine" id="cb18-26" title="26"></a>
<a class="sourceLine" id="cb18-27" title="27"><span class="co">// free memory associated with Tree</span></a>
<a class="sourceLine" id="cb18-28" title="28"><span class="dt">void</span> dropTree (Tree t)</a>
<a class="sourceLine" id="cb18-29" title="29">{</a>
<a class="sourceLine" id="cb18-30" title="30">    <span class="cf">if</span> (t == NULL) <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb18-31" title="31">    dropTree (t-&gt;left);</a>
<a class="sourceLine" id="cb18-32" title="32">    dropTree (t-&gt;right);</a>
<a class="sourceLine" id="cb18-33" title="33">    free (t);</a>
<a class="sourceLine" id="cb18-34" title="34">}</a>
<a class="sourceLine" id="cb18-35" title="35"></a>
<a class="sourceLine" id="cb18-36" title="36"><span class="co">// display a Tree (sideways)</span></a>
<a class="sourceLine" id="cb18-37" title="37"><span class="dt">void</span> showTree (Tree t)</a>
<a class="sourceLine" id="cb18-38" title="38">{</a>
<a class="sourceLine" id="cb18-39" title="39">    <span class="dt">void</span> doShowTree (Tree);</a>
<a class="sourceLine" id="cb18-40" title="40">    doShowTree (t);</a>
<a class="sourceLine" id="cb18-41" title="41">}</a>
<a class="sourceLine" id="cb18-42" title="42"></a>
<a class="sourceLine" id="cb18-43" title="43"><span class="co">// insert a new value into a Tree</span></a>
<a class="sourceLine" id="cb18-44" title="44">Tree TreeInsert (Tree t, Item it)</a>
<a class="sourceLine" id="cb18-45" title="45">{</a>
<a class="sourceLine" id="cb18-46" title="46">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb18-47" title="47">        <span class="cf">return</span> newNode (it);</a>
<a class="sourceLine" id="cb18-48" title="48">    <span class="dt">int</span> diff = cmp (key (it), key (t-&gt;value));</a>
<a class="sourceLine" id="cb18-49" title="49">    <span class="cf">if</span> (diff == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-50" title="50">        t-&gt;value = it;</a>
<a class="sourceLine" id="cb18-51" title="51">    <span class="cf">else</span> <span class="cf">if</span> (diff &lt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-52" title="52">        t-&gt;left = TreeInsert (t-&gt;left, it);</a>
<a class="sourceLine" id="cb18-53" title="53">    <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-54" title="54">        t-&gt;right = TreeInsert (t-&gt;right, it);</a>
<a class="sourceLine" id="cb18-55" title="55">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb18-56" title="56">}</a>
<a class="sourceLine" id="cb18-57" title="57"></a>
<a class="sourceLine" id="cb18-58" title="58"><span class="co">// insert a new value as root of Tree</span></a>
<a class="sourceLine" id="cb18-59" title="59">Tree insertAtRoot (Tree t, Item it)</a>
<a class="sourceLine" id="cb18-60" title="60">{</a>
<a class="sourceLine" id="cb18-61" title="61">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb18-62" title="62">        <span class="cf">return</span> newNode (it);</a>
<a class="sourceLine" id="cb18-63" title="63">    <span class="dt">int</span> diff = cmp (key (it), key (t-&gt;value));</a>
<a class="sourceLine" id="cb18-64" title="64">    <span class="cf">if</span> (diff == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-65" title="65">        t-&gt;value = it;</a>
<a class="sourceLine" id="cb18-66" title="66">    <span class="cf">else</span> <span class="cf">if</span> (diff &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb18-67" title="67">        t-&gt;left = insertAtRoot (t-&gt;left, it);</a>
<a class="sourceLine" id="cb18-68" title="68">        printf (<span class="st">"rotateR(%d)</span><span class="sc">\n</span><span class="st">"</span>, t-&gt;value);</a>
<a class="sourceLine" id="cb18-69" title="69">        t = rotateR (t);</a>
<a class="sourceLine" id="cb18-70" title="70">    } <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb18-71" title="71">        t-&gt;right = insertAtRoot (t-&gt;right, it);</a>
<a class="sourceLine" id="cb18-72" title="72">        printf (<span class="st">"rotateL(%d)</span><span class="sc">\n</span><span class="st">"</span>, t-&gt;value);</a>
<a class="sourceLine" id="cb18-73" title="73">        t = rotateL (t);</a>
<a class="sourceLine" id="cb18-74" title="74">    }</a>
<a class="sourceLine" id="cb18-75" title="75">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb18-76" title="76">}</a>
<a class="sourceLine" id="cb18-77" title="77"></a>
<a class="sourceLine" id="cb18-78" title="78">Tree insertRandom (Tree t, Item it)</a>
<a class="sourceLine" id="cb18-79" title="79">{</a>
<a class="sourceLine" id="cb18-80" title="80">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb18-81" title="81">        <span class="cf">return</span> newNode (it);</a>
<a class="sourceLine" id="cb18-82" title="82">    <span class="co">// 1 in 3 chance of doing root insert</span></a>
<a class="sourceLine" id="cb18-83" title="83">    <span class="dt">int</span> chance = rand () % <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb18-84" title="84">    <span class="cf">if</span> (chance == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-85" title="85">        t = insertAtRoot (t, it);</a>
<a class="sourceLine" id="cb18-86" title="86">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb18-87" title="87">        t = TreeInsert (t, it);</a>
<a class="sourceLine" id="cb18-88" title="88">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb18-89" title="89">}</a>
<a class="sourceLine" id="cb18-90" title="90"></a>
<a class="sourceLine" id="cb18-91" title="91"><span class="co">// delete item with given key from Tree</span></a>
<a class="sourceLine" id="cb18-92" title="92">Tree TreeDelete (Tree t, Key k)</a>
<a class="sourceLine" id="cb18-93" title="93">{</a>
<a class="sourceLine" id="cb18-94" title="94">    Tree deleteRoot (Tree);</a>
<a class="sourceLine" id="cb18-95" title="95"></a>
<a class="sourceLine" id="cb18-96" title="96">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb18-97" title="97">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb18-98" title="98">    <span class="dt">int</span> diff = cmp (k, key (t-&gt;value));</a>
<a class="sourceLine" id="cb18-99" title="99">    <span class="cf">if</span> (diff == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-100" title="100">        t = deleteRoot (t);</a>
<a class="sourceLine" id="cb18-101" title="101">    <span class="cf">else</span> <span class="cf">if</span> (diff &lt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-102" title="102">        t-&gt;left = TreeDelete (t-&gt;left, k);</a>
<a class="sourceLine" id="cb18-103" title="103">    <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-104" title="104">        t-&gt;right = TreeDelete (t-&gt;right, k);</a>
<a class="sourceLine" id="cb18-105" title="105">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb18-106" title="106">}</a>
<a class="sourceLine" id="cb18-107" title="107"></a>
<a class="sourceLine" id="cb18-108" title="108"><span class="co">// delete root of tree</span></a>
<a class="sourceLine" id="cb18-109" title="109">Tree deleteRoot (Tree t)</a>
<a class="sourceLine" id="cb18-110" title="110">{</a>
<a class="sourceLine" id="cb18-111" title="111">    Link newRoot;</a>
<a class="sourceLine" id="cb18-112" title="112">    <span class="co">// if no subtrees, tree empty after delete</span></a>
<a class="sourceLine" id="cb18-113" title="113">    <span class="cf">if</span> (t-&gt;left == NULL &amp;&amp; t-&gt;right == NULL) {</a>
<a class="sourceLine" id="cb18-114" title="114">        free (t);</a>
<a class="sourceLine" id="cb18-115" title="115">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb18-116" title="116">    }</a>
<a class="sourceLine" id="cb18-117" title="117">    <span class="co">// if only right subtree, make it the new root</span></a>
<a class="sourceLine" id="cb18-118" title="118">    <span class="cf">else</span> <span class="cf">if</span> (t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL) {</a>
<a class="sourceLine" id="cb18-119" title="119">        newRoot = t-&gt;right;</a>
<a class="sourceLine" id="cb18-120" title="120">        free (t);</a>
<a class="sourceLine" id="cb18-121" title="121">        <span class="cf">return</span> newRoot;</a>
<a class="sourceLine" id="cb18-122" title="122">    }</a>
<a class="sourceLine" id="cb18-123" title="123">    <span class="co">// if only left subtree, make it the new root</span></a>
<a class="sourceLine" id="cb18-124" title="124">    <span class="cf">else</span> <span class="cf">if</span> (t-&gt;left != NULL &amp;&amp; t-&gt;right == NULL) {</a>
<a class="sourceLine" id="cb18-125" title="125">        newRoot = t-&gt;left;</a>
<a class="sourceLine" id="cb18-126" title="126">        free (t);</a>
<a class="sourceLine" id="cb18-127" title="127">        <span class="cf">return</span> newRoot;</a>
<a class="sourceLine" id="cb18-128" title="128">    }</a>
<a class="sourceLine" id="cb18-129" title="129">    <span class="co">// else (t-&gt;left != NULL &amp;&amp; t-&gt;right != NULL)</span></a>
<a class="sourceLine" id="cb18-130" title="130">    <span class="co">// so has two subtrees</span></a>
<a class="sourceLine" id="cb18-131" title="131">    <span class="co">// - find inorder successor (grab value)</span></a>
<a class="sourceLine" id="cb18-132" title="132">    <span class="co">// - delete inorder successor node</span></a>
<a class="sourceLine" id="cb18-133" title="133">    <span class="co">// - move its value to root</span></a>
<a class="sourceLine" id="cb18-134" title="134">    Link succ = t-&gt;right; <span class="co">// not null!</span></a>
<a class="sourceLine" id="cb18-135" title="135">    <span class="cf">while</span> (succ-&gt;left != NULL) {</a>
<a class="sourceLine" id="cb18-136" title="136">        succ = succ-&gt;left;</a>
<a class="sourceLine" id="cb18-137" title="137">    }</a>
<a class="sourceLine" id="cb18-138" title="138">    <span class="dt">int</span> succVal = succ-&gt;value;</a>
<a class="sourceLine" id="cb18-139" title="139">    t = TreeDelete (t, succVal);</a>
<a class="sourceLine" id="cb18-140" title="140">    t-&gt;value = succVal;</a>
<a class="sourceLine" id="cb18-141" title="141">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb18-142" title="142">}</a>
<a class="sourceLine" id="cb18-143" title="143"></a>
<a class="sourceLine" id="cb18-144" title="144"><span class="co">// check whether item with given key is in Tree</span></a>
<a class="sourceLine" id="cb18-145" title="145"><span class="dt">int</span> TreeFind (Tree t, Key k)</a>
<a class="sourceLine" id="cb18-146" title="146">{</a>
<a class="sourceLine" id="cb18-147" title="147">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb18-148" title="148">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb18-149" title="149">    <span class="dt">int</span> res, diff = cmp (k, key (t-&gt;value));</a>
<a class="sourceLine" id="cb18-150" title="150">    <span class="cf">if</span> (diff &lt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-151" title="151">        res = TreeFind (t-&gt;left, k);</a>
<a class="sourceLine" id="cb18-152" title="152">    <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb18-153" title="153">        res = TreeFind (t-&gt;right, k);</a>
<a class="sourceLine" id="cb18-154" title="154">    <span class="cf">else</span> <span class="co">// (diff == 0)</span></a>
<a class="sourceLine" id="cb18-155" title="155">        res = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb18-156" title="156">    <span class="cf">return</span> res;</a>
<a class="sourceLine" id="cb18-157" title="157">}</a>
<a class="sourceLine" id="cb18-158" title="158"></a>
<a class="sourceLine" id="cb18-159" title="159"><span class="co">// compute depth of Tree</span></a>
<a class="sourceLine" id="cb18-160" title="160"><span class="dt">int</span> TreeDepth (Tree t)</a>
<a class="sourceLine" id="cb18-161" title="161">{</a>
<a class="sourceLine" id="cb18-162" title="162">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb18-163" title="163">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb18-164" title="164">    <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb18-165" title="165">        <span class="dt">int</span> ldepth = TreeDepth (t-&gt;left);</a>
<a class="sourceLine" id="cb18-166" title="166">        <span class="dt">int</span> rdepth = TreeDepth (t-&gt;right);</a>
<a class="sourceLine" id="cb18-167" title="167">        <span class="co">// return 1 + (ldepth &gt; rdepth)?ldepth:rdepth;</span></a>
<a class="sourceLine" id="cb18-168" title="168">        <span class="cf">if</span> (ldepth &gt; rdepth)</a>
<a class="sourceLine" id="cb18-169" title="169">            <span class="cf">return</span> <span class="dv">1</span> + ldepth;</a>
<a class="sourceLine" id="cb18-170" title="170">        <span class="cf">else</span></a>
<a class="sourceLine" id="cb18-171" title="171">            <span class="cf">return</span> <span class="dv">1</span> + rdepth;</a>
<a class="sourceLine" id="cb18-172" title="172">    }</a>
<a class="sourceLine" id="cb18-173" title="173">}</a>
<a class="sourceLine" id="cb18-174" title="174"></a>
<a class="sourceLine" id="cb18-175" title="175"><span class="co">// count #nodes in Tree</span></a>
<a class="sourceLine" id="cb18-176" title="176"><span class="dt">int</span> TreeNumNodes (Tree t)</a>
<a class="sourceLine" id="cb18-177" title="177">{</a>
<a class="sourceLine" id="cb18-178" title="178">    <span class="cf">if</span> (t == NULL) <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb18-179" title="179">    <span class="cf">return</span> <span class="dv">1</span> + TreeNumNodes (t-&gt;left) + TreeNumNodes (t-&gt;right);</a>
<a class="sourceLine" id="cb18-180" title="180">}</a>
<a class="sourceLine" id="cb18-181" title="181"></a>
<a class="sourceLine" id="cb18-182" title="182"><span class="co">// fetch i'th (from left) item from Tree</span></a>
<a class="sourceLine" id="cb18-183" title="183">Item *get_ith (Tree t, <span class="dt">int</span> i)</a>
<a class="sourceLine" id="cb18-184" title="184">{</a>
<a class="sourceLine" id="cb18-185" title="185">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb18-186" title="186">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb18-187" title="187">    assert (<span class="dv">0</span> &lt;= i &amp;&amp; i &lt; size (t));</a>
<a class="sourceLine" id="cb18-188" title="188">    <span class="dt">int</span> n = size (t-&gt;left); <span class="co">// #nodes to left of root</span></a>
<a class="sourceLine" id="cb18-189" title="189">    <span class="cf">if</span> (i &lt; n)</a>
<a class="sourceLine" id="cb18-190" title="190">        <span class="cf">return</span> get_ith (t-&gt;left, i);</a>
<a class="sourceLine" id="cb18-191" title="191">    <span class="cf">if</span> (i &gt; n)</a>
<a class="sourceLine" id="cb18-192" title="192">        <span class="cf">return</span> get_ith (t-&gt;right, i - n - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb18-193" title="193">    <span class="cf">return</span> &amp;(t-&gt;value);</a>
<a class="sourceLine" id="cb18-194" title="194">}</a>
<a class="sourceLine" id="cb18-195" title="195"></a>
<a class="sourceLine" id="cb18-196" title="196"><span class="co">// partition Tree around i'th Item</span></a>
<a class="sourceLine" id="cb18-197" title="197">Tree partition (Tree t, <span class="dt">int</span> i)</a>
<a class="sourceLine" id="cb18-198" title="198">{</a>
<a class="sourceLine" id="cb18-199" title="199">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb18-200" title="200">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb18-201" title="201">    assert (<span class="dv">0</span> &lt;= i &amp;&amp; i &lt; size (t));</a>
<a class="sourceLine" id="cb18-202" title="202">    <span class="dt">int</span> n = size (t-&gt;left);</a>
<a class="sourceLine" id="cb18-203" title="203">    <span class="cf">if</span> (i &lt; n) {</a>
<a class="sourceLine" id="cb18-204" title="204">        t-&gt;left = partition (t-&gt;left, i);</a>
<a class="sourceLine" id="cb18-205" title="205">        t = rotateR (t);</a>
<a class="sourceLine" id="cb18-206" title="206">    }</a>
<a class="sourceLine" id="cb18-207" title="207">    <span class="cf">if</span> (i &gt; n) {</a>
<a class="sourceLine" id="cb18-208" title="208">        t-&gt;right = partition (t-&gt;right, i - n - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb18-209" title="209">        t = rotateL (t);</a>
<a class="sourceLine" id="cb18-210" title="210">    }</a>
<a class="sourceLine" id="cb18-211" title="211">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb18-212" title="212">}</a>
<a class="sourceLine" id="cb18-213" title="213"></a>
<a class="sourceLine" id="cb18-214" title="214"><span class="co">// rotate Tree right around node</span></a>
<a class="sourceLine" id="cb18-215" title="215">Link rotateR (Link n1)</a>
<a class="sourceLine" id="cb18-216" title="216">{</a>
<a class="sourceLine" id="cb18-217" title="217">    <span class="cf">if</span> (n1 == NULL)</a>
<a class="sourceLine" id="cb18-218" title="218">        <span class="cf">return</span> n1;</a>
<a class="sourceLine" id="cb18-219" title="219">    Link n2 = n1-&gt;left;</a>
<a class="sourceLine" id="cb18-220" title="220">    <span class="cf">if</span> (n2 == NULL)</a>
<a class="sourceLine" id="cb18-221" title="221">        <span class="cf">return</span> n1;</a>
<a class="sourceLine" id="cb18-222" title="222">    n1-&gt;left = n2-&gt;right;</a>
<a class="sourceLine" id="cb18-223" title="223">    n2-&gt;right = n1;</a>
<a class="sourceLine" id="cb18-224" title="224">    <span class="cf">return</span> n2;</a>
<a class="sourceLine" id="cb18-225" title="225">}</a>
<a class="sourceLine" id="cb18-226" title="226"></a>
<a class="sourceLine" id="cb18-227" title="227"><span class="co">// rotate Tree left around node</span></a>
<a class="sourceLine" id="cb18-228" title="228">Link rotateL (Link n2)</a>
<a class="sourceLine" id="cb18-229" title="229">{</a>
<a class="sourceLine" id="cb18-230" title="230">    <span class="cf">if</span> (n2 == NULL)</a>
<a class="sourceLine" id="cb18-231" title="231">        <span class="cf">return</span> n2;</a>
<a class="sourceLine" id="cb18-232" title="232">    Link n1 = n2-&gt;right;</a>
<a class="sourceLine" id="cb18-233" title="233">    <span class="cf">if</span> (n1 == NULL)</a>
<a class="sourceLine" id="cb18-234" title="234">        <span class="cf">return</span> n2;</a>
<a class="sourceLine" id="cb18-235" title="235">    n2-&gt;right = n1-&gt;left;</a>
<a class="sourceLine" id="cb18-236" title="236">    n1-&gt;left = n2;</a>
<a class="sourceLine" id="cb18-237" title="237">    <span class="cf">return</span> n1;</a>
<a class="sourceLine" id="cb18-238" title="238">}</a></code></pre></div>
</div>
<p>Note that the above has operations relevant for balancing; the tree types below are specificaly designed to be balanced.</p>
<div class="panel panel-default">
<div id="splay-tree" class="panel-heading">
<strong> Splay Trees </strong>
</div>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="co">// tree_splay.c</span></a>
<a class="sourceLine" id="cb19-2" title="2"></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="pp">#define L left</span></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="pp">#define R right</span></a>
<a class="sourceLine" id="cb19-5" title="5"></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="co">// Other operations are as for BSTs</span></a>
<a class="sourceLine" id="cb19-7" title="7">Tree insertSplay (Tree t, Item it)</a>
<a class="sourceLine" id="cb19-8" title="8">{</a>
<a class="sourceLine" id="cb19-9" title="9">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb19-10" title="10">        <span class="cf">return</span> newNode (it);</a>
<a class="sourceLine" id="cb19-11" title="11">    <span class="dt">int</span> diff = cmp (key (it), key (t-&gt;value));</a>
<a class="sourceLine" id="cb19-12" title="12">    <span class="cf">if</span> (diff == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb19-13" title="13">        t-&gt;value = it;</a>
<a class="sourceLine" id="cb19-14" title="14">    <span class="cf">else</span> <span class="cf">if</span> (diff &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb19-15" title="15">        <span class="cf">if</span> (t-&gt;L == NULL) {</a>
<a class="sourceLine" id="cb19-16" title="16">            t-&gt;L = newNode (it);</a>
<a class="sourceLine" id="cb19-17" title="17">            t-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-18" title="18">        }</a>
<a class="sourceLine" id="cb19-19" title="19">        <span class="dt">int</span> ldiff = cmp (key (it), key (t-&gt;L-&gt;value));</a>
<a class="sourceLine" id="cb19-20" title="20">        <span class="cf">if</span> (ldiff &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb19-21" title="21">            <span class="co">// Case 1: left-child of left-child</span></a>
<a class="sourceLine" id="cb19-22" title="22">            t-&gt;L-&gt;L = insertSplay (t-&gt;L-&gt;L, it);</a>
<a class="sourceLine" id="cb19-23" title="23">            t-&gt;L-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-24" title="24">            t-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-25" title="25">            t = rotateR (t);</a>
<a class="sourceLine" id="cb19-26" title="26">        } <span class="cf">else</span> <span class="cf">if</span> (ldiff &gt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb19-27" title="27">            <span class="co">// Case 2: right-child of left-child</span></a>
<a class="sourceLine" id="cb19-28" title="28">            t-&gt;L-&gt;R = insertSplay (t-&gt;L-&gt;R, it);</a>
<a class="sourceLine" id="cb19-29" title="29">            t-&gt;L-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-30" title="30">            t-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-31" title="31">            t-&gt;L = rotateL (t-&gt;L);</a>
<a class="sourceLine" id="cb19-32" title="32">        }</a>
<a class="sourceLine" id="cb19-33" title="33">        <span class="cf">return</span> rotateR (t);</a>
<a class="sourceLine" id="cb19-34" title="34">    } <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb19-35" title="35">        <span class="cf">if</span> (t-&gt;R == NULL) {</a>
<a class="sourceLine" id="cb19-36" title="36">            t-&gt;R = newNode (it);</a>
<a class="sourceLine" id="cb19-37" title="37">            t-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-38" title="38">        }</a>
<a class="sourceLine" id="cb19-39" title="39">        <span class="dt">int</span> rdiff = cmp (key (it), key (t-&gt;R-&gt;value));</a>
<a class="sourceLine" id="cb19-40" title="40">        <span class="cf">if</span> (rdiff &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb19-41" title="41">            <span class="co">// Case 3: left-child of right-child</span></a>
<a class="sourceLine" id="cb19-42" title="42">            t-&gt;R-&gt;L = insertSplay (t-&gt;R-&gt;L, it);</a>
<a class="sourceLine" id="cb19-43" title="43">            t-&gt;R-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-44" title="44">            t-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-45" title="45">            t-&gt;R = rotateR (t-&gt;R);</a>
<a class="sourceLine" id="cb19-46" title="46">        } <span class="cf">else</span> <span class="cf">if</span> (rdiff &gt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb19-47" title="47">            <span class="co">// Case 4: right-child of right-child</span></a>
<a class="sourceLine" id="cb19-48" title="48">            t-&gt;R-&gt;R = insertSplay (t-&gt;R-&gt;R, it);</a>
<a class="sourceLine" id="cb19-49" title="49">            t-&gt;R-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-50" title="50">            t-&gt;nnodes++;</a>
<a class="sourceLine" id="cb19-51" title="51">            t = rotateL (t);</a>
<a class="sourceLine" id="cb19-52" title="52">        }</a>
<a class="sourceLine" id="cb19-53" title="53">        <span class="cf">return</span> rotateL (t);</a>
<a class="sourceLine" id="cb19-54" title="54">    } <span class="cf">else</span></a>
<a class="sourceLine" id="cb19-55" title="55">        t-&gt;value = it;</a>
<a class="sourceLine" id="cb19-56" title="56">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb19-57" title="57">}</a>
<a class="sourceLine" id="cb19-58" title="58"></a>
<a class="sourceLine" id="cb19-59" title="59"><span class="co">// search Tree for item with key k</span></a>
<a class="sourceLine" id="cb19-60" title="60">Item *searchSplay (Tree *t, Key k)</a>
<a class="sourceLine" id="cb19-61" title="61">{</a>
<a class="sourceLine" id="cb19-62" title="62">    Link root = *t;</a>
<a class="sourceLine" id="cb19-63" title="63">    <span class="cf">if</span> (root == NULL)</a>
<a class="sourceLine" id="cb19-64" title="64">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb19-65" title="65">    root = splay (root, k);</a>
<a class="sourceLine" id="cb19-66" title="66">    *t = root;</a>
<a class="sourceLine" id="cb19-67" title="67">    <span class="cf">if</span> (key (root-&gt;value) == k)</a>
<a class="sourceLine" id="cb19-68" title="68">        <span class="cf">return</span> &amp;(root-&gt;value);</a>
<a class="sourceLine" id="cb19-69" title="69">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb19-70" title="70">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb19-71" title="71">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="avl-tree" class="panel-heading">
<strong> AVL Trees </strong>
</div>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="co">// tree_avl.c</span></a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="co">// Other operations are as for BSTs</span></a>
<a class="sourceLine" id="cb20-4" title="4">Tree insertAVL (Tree t, Item it)</a>
<a class="sourceLine" id="cb20-5" title="5">{</a>
<a class="sourceLine" id="cb20-6" title="6">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb20-7" title="7">        <span class="cf">return</span> newNode (it);</a>
<a class="sourceLine" id="cb20-8" title="8">    <span class="dt">int</span> diff = cmp (key (it), key (t-&gt;value));</a>
<a class="sourceLine" id="cb20-9" title="9">    <span class="cf">if</span> (diff == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb20-10" title="10">        t-&gt;value = it;</a>
<a class="sourceLine" id="cb20-11" title="11">    } <span class="cf">else</span> <span class="cf">if</span> (diff &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb20-12" title="12">        t-&gt;left = insertAVL (t-&gt;left, it);</a>
<a class="sourceLine" id="cb20-13" title="13">        t-&gt;nnodes = count (t);</a>
<a class="sourceLine" id="cb20-14" title="14">    } <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb20-15" title="15">        t-&gt;right = insertAVL (t-&gt;right, it);</a>
<a class="sourceLine" id="cb20-16" title="16">        t-&gt;nnodes = count (t);</a>
<a class="sourceLine" id="cb20-17" title="17">    }</a>
<a class="sourceLine" id="cb20-18" title="18"></a>
<a class="sourceLine" id="cb20-19" title="19">    <span class="dt">int</span> dL = depth (t-&gt;left);</a>
<a class="sourceLine" id="cb20-20" title="20">    <span class="dt">int</span> dR = depth (t-&gt;right);</a>
<a class="sourceLine" id="cb20-21" title="21">    <span class="cf">if</span> ((dL - dR) &gt; <span class="dv">1</span>) t = rotateR (t);</a>
<a class="sourceLine" id="cb20-22" title="22">    <span class="cf">else</span> <span class="cf">if</span> ((dR - dL) &gt; <span class="dv">1</span>) t = rotateL (t);</a>
<a class="sourceLine" id="cb20-23" title="23">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb20-24" title="24">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="234-tree" class="panel-heading">
<strong> 2-3-4 Trees </strong>
</div>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="pp">#include </span><span class="im">"tree_234.h"</span></a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">typedef</span> <span class="kw">struct</span> node {</a>
<a class="sourceLine" id="cb21-4" title="4">    <span class="dt">int</span> order;   <span class="co">// 2, 3 or 4</span></a>
<a class="sourceLine" id="cb21-5" title="5">    Item data[<span class="dv">3</span>];  <span class="co">// items in node</span></a>
<a class="sourceLine" id="cb21-6" title="6">    Tree child[<span class="dv">4</span>]; <span class="co">// links to subtrees</span></a>
<a class="sourceLine" id="cb21-7" title="7">} Node;</a>
<a class="sourceLine" id="cb21-8" title="8"></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="co">// create new 2-3-4 node</span></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="dt">static</span> Node *newNode (Item it)</a>
<a class="sourceLine" id="cb21-11" title="11">{</a>
<a class="sourceLine" id="cb21-12" title="12">    Node *new = malloc (<span class="kw">sizeof</span> (Node));</a>
<a class="sourceLine" id="cb21-13" title="13">    assert (new != NULL);</a>
<a class="sourceLine" id="cb21-14" title="14">    new-&gt;order = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb21-15" title="15">    new-&gt;data[<span class="dv">0</span>] = it;</a>
<a class="sourceLine" id="cb21-16" title="16">    new-&gt;child[<span class="dv">0</span>] = new-&gt;child[<span class="dv">1</span>] = NULL;</a>
<a class="sourceLine" id="cb21-17" title="17">    <span class="cf">return</span> new;</a>
<a class="sourceLine" id="cb21-18" title="18">}</a>
<a class="sourceLine" id="cb21-19" title="19"></a>
<a class="sourceLine" id="cb21-20" title="20"><span class="co">// search for item with key k</span></a>
<a class="sourceLine" id="cb21-21" title="21">Item *search (Tree t, Key k)</a>
<a class="sourceLine" id="cb21-22" title="22">{</a>
<a class="sourceLine" id="cb21-23" title="23">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb21-24" title="24">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb21-25" title="25">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb21-26" title="26">    <span class="dt">int</span> diff;</a>
<a class="sourceLine" id="cb21-27" title="27">    <span class="dt">int</span> nitems = t-&gt;order - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb21-28" title="28">    <span class="co">// find relevant slot in items</span></a>
<a class="sourceLine" id="cb21-29" title="29">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; nitems; i++) {</a>
<a class="sourceLine" id="cb21-30" title="30">        diff = cmp (k, key (t-&gt;data[i]));</a>
<a class="sourceLine" id="cb21-31" title="31">        <span class="cf">if</span> (diff &lt;= <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb21-32" title="32">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb21-33" title="33">    }</a>
<a class="sourceLine" id="cb21-34" title="34">    <span class="cf">if</span> (diff == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb21-35" title="35">        <span class="co">// match; return result</span></a>
<a class="sourceLine" id="cb21-36" title="36">        <span class="cf">return</span> &amp;(t-&gt;data[i]);</a>
<a class="sourceLine" id="cb21-37" title="37">    <span class="cf">else</span></a>
<a class="sourceLine" id="cb21-38" title="38">        <span class="co">// keep looking in relevant subtree</span></a>
<a class="sourceLine" id="cb21-39" title="39">        <span class="cf">return</span> search (t-&gt;child[i], k);</a>
<a class="sourceLine" id="cb21-40" title="40">}</a>
<a class="sourceLine" id="cb21-41" title="41"></a>
<a class="sourceLine" id="cb21-42" title="42"><span class="co">// insert new Item into Tree</span></a>
<a class="sourceLine" id="cb21-43" title="43">Tree</a>
<a class="sourceLine" id="cb21-44" title="44">insert (Tree t, Item it)</a>
<a class="sourceLine" id="cb21-45" title="45">{</a>
<a class="sourceLine" id="cb21-46" title="46">    <span class="co">/* algorithm:</span></a>
<a class="sourceLine" id="cb21-47" title="47"><span class="co">    find leaf node where Item belongs (via search)</span></a>
<a class="sourceLine" id="cb21-48" title="48"><span class="co">    if not full (i.e. order &lt; 4) {</span></a>
<a class="sourceLine" id="cb21-49" title="49"><span class="co">        insert Item in this node, order++</span></a>
<a class="sourceLine" id="cb21-50" title="50"><span class="co">    }</span></a>
<a class="sourceLine" id="cb21-51" title="51"><span class="co">    else if node is full (i.e. contains 3 Items) {</span></a>
<a class="sourceLine" id="cb21-52" title="52"><span class="co">        split into two 2-nodes as leaves</span></a>
<a class="sourceLine" id="cb21-53" title="53"><span class="co">        promote middle element to parent</span></a>
<a class="sourceLine" id="cb21-54" title="54"><span class="co">        insert item into appropriate leaf 2-node</span></a>
<a class="sourceLine" id="cb21-55" title="55"><span class="co">        if parent is a 4-node {</span></a>
<a class="sourceLine" id="cb21-56" title="56"><span class="co">            continue split/promote upwards</span></a>
<a class="sourceLine" id="cb21-57" title="57"><span class="co">            if promote to root, and root is a 4-node {</span></a>
<a class="sourceLine" id="cb21-58" title="58"><span class="co">                split root node</span></a>
<a class="sourceLine" id="cb21-59" title="59"><span class="co">                add new root node</span></a>
<a class="sourceLine" id="cb21-60" title="60"><span class="co">                promote middle item to new root</span></a>
<a class="sourceLine" id="cb21-61" title="61"><span class="co">            }</span></a>
<a class="sourceLine" id="cb21-62" title="62"><span class="co">        }</span></a>
<a class="sourceLine" id="cb21-63" title="63"><span class="co">    }</span></a>
<a class="sourceLine" id="cb21-64" title="64"><span class="co">    */</span></a>
<a class="sourceLine" id="cb21-65" title="65">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="rb-tree" class="panel-heading">
<strong> Red-Black Trees </strong>
</div>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="co">// tree_rb.c</span></a>
<a class="sourceLine" id="cb22-2" title="2"></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="kw">typedef</span> <span class="kw">enum</span> { RED, BLACK } color_t;</a>
<a class="sourceLine" id="cb22-4" title="4"><span class="kw">typedef</span> <span class="kw">struct</span> Node *Link;</a>
<a class="sourceLine" id="cb22-5" title="5"><span class="kw">typedef</span> <span class="kw">struct</span> TreeRep *Tree;</a>
<a class="sourceLine" id="cb22-6" title="6"><span class="kw">struct</span> TreeRep {</a>
<a class="sourceLine" id="cb22-7" title="7">    Link root;</a>
<a class="sourceLine" id="cb22-8" title="8">};</a>
<a class="sourceLine" id="cb22-9" title="9"><span class="kw">typedef</span> <span class="kw">struct</span> Node {</a>
<a class="sourceLine" id="cb22-10" title="10">    Item value;  <span class="co">// actual data</span></a>
<a class="sourceLine" id="cb22-11" title="11">    color_t colour; <span class="co">// colour of link to parent</span></a>
<a class="sourceLine" id="cb22-12" title="12">    Link left;   <span class="co">// left subtree</span></a>
<a class="sourceLine" id="cb22-13" title="13">    Link right;  <span class="co">// right subtree</span></a>
<a class="sourceLine" id="cb22-14" title="14">} Node;</a>
<a class="sourceLine" id="cb22-15" title="15"></a>
<a class="sourceLine" id="cb22-16" title="16"><span class="co">// make new node to hold supplied Item</span></a>
<a class="sourceLine" id="cb22-17" title="17">Node *newNode (Item it, color_t c)</a>
<a class="sourceLine" id="cb22-18" title="18">{</a>
<a class="sourceLine" id="cb22-19" title="19">    Node *new = malloc (<span class="kw">sizeof</span> (Node));</a>
<a class="sourceLine" id="cb22-20" title="20">    assert (new != NULL);</a>
<a class="sourceLine" id="cb22-21" title="21">    new-&gt;value = it;</a>
<a class="sourceLine" id="cb22-22" title="22">    new-&gt;colour = c;</a>
<a class="sourceLine" id="cb22-23" title="23">    new-&gt;left = new-&gt;right = NULL;</a>
<a class="sourceLine" id="cb22-24" title="24">    <span class="cf">return</span> new;</a>
<a class="sourceLine" id="cb22-25" title="25">}</a>
<a class="sourceLine" id="cb22-26" title="26"></a>
<a class="sourceLine" id="cb22-27" title="27"><span class="co">// search for Item with given key</span></a>
<a class="sourceLine" id="cb22-28" title="28">Item *search (Link t, Key k)</a>
<a class="sourceLine" id="cb22-29" title="29">{</a>
<a class="sourceLine" id="cb22-30" title="30">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb22-31" title="31">        <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb22-32" title="32">    <span class="dt">int</span> diff = cmp (k, key (t-&gt;value));</a>
<a class="sourceLine" id="cb22-33" title="33">    <span class="cf">if</span> (diff &lt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb22-34" title="34">        <span class="cf">return</span> search (t-&gt;left, k);</a>
<a class="sourceLine" id="cb22-35" title="35">    <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb22-36" title="36">        <span class="cf">return</span> search (t-&gt;right, k);</a>
<a class="sourceLine" id="cb22-37" title="37">    <span class="cf">else</span> <span class="co">// matches</span></a>
<a class="sourceLine" id="cb22-38" title="38">        <span class="cf">return</span> &amp;(t-&gt;value);</a>
<a class="sourceLine" id="cb22-39" title="39">}</a>
<a class="sourceLine" id="cb22-40" title="40"></a>
<a class="sourceLine" id="cb22-41" title="41"><span class="co">// insert new Item into tree</span></a>
<a class="sourceLine" id="cb22-42" title="42"><span class="pp">#define L left</span></a>
<a class="sourceLine" id="cb22-43" title="43"><span class="pp">#define R right</span></a>
<a class="sourceLine" id="cb22-44" title="44"><span class="pp">#define isRed(t) ((t) != NULL &amp;&amp; (t)-&gt;colour == RED)</span></a>
<a class="sourceLine" id="cb22-45" title="45"></a>
<a class="sourceLine" id="cb22-46" title="46"><span class="dt">void</span> insert (Tree t, Item it)</a>
<a class="sourceLine" id="cb22-47" title="47">{</a>
<a class="sourceLine" id="cb22-48" title="48">    t-&gt;root = insertRB (t-&gt;root, it, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb22-49" title="49">    t-&gt;root-&gt;colour = RED;</a>
<a class="sourceLine" id="cb22-50" title="50">}</a>
<a class="sourceLine" id="cb22-51" title="51"></a>
<a class="sourceLine" id="cb22-52" title="52">Link insertRB (Link t, Item it, <span class="dt">int</span> inRight)</a>
<a class="sourceLine" id="cb22-53" title="53">{</a>
<a class="sourceLine" id="cb22-54" title="54">    <span class="cf">if</span> (t == NULL)</a>
<a class="sourceLine" id="cb22-55" title="55">        <span class="cf">return</span> newNode (it, RED);</a>
<a class="sourceLine" id="cb22-56" title="56">    <span class="co">// node is a 4-node; lift it</span></a>
<a class="sourceLine" id="cb22-57" title="57">    <span class="cf">if</span> (isRed (t-&gt;L) &amp;&amp; isRed (t-&gt;R)) {</a>
<a class="sourceLine" id="cb22-58" title="58">        t-&gt;colour = RED;</a>
<a class="sourceLine" id="cb22-59" title="59">        t-&gt;L-&gt;colour = BLACK;</a>
<a class="sourceLine" id="cb22-60" title="60">        t-&gt;R-&gt;colour = BLACK;</a>
<a class="sourceLine" id="cb22-61" title="61">    }</a>
<a class="sourceLine" id="cb22-62" title="62">    <span class="dt">int</span> diff = cmp (key (it), key (t-&gt;value));</a>
<a class="sourceLine" id="cb22-63" title="63">    <span class="cf">if</span> (diff == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb22-64" title="64">        t-&gt;value = it;</a>
<a class="sourceLine" id="cb22-65" title="65">    <span class="cf">else</span> <span class="cf">if</span> (diff &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb22-66" title="66">        t-&gt;L = insertRB (t-&gt;L, it, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb22-67" title="67">        <span class="cf">if</span> (isRed (t) &amp;&amp; isRed (t-&gt;L) &amp;&amp; inRight)</a>
<a class="sourceLine" id="cb22-68" title="68">            t = rotateR (t);</a>
<a class="sourceLine" id="cb22-69" title="69">        <span class="cf">if</span> (isRed (t-&gt;L) &amp;&amp; isRed (t-&gt;L-&gt;L)) {</a>
<a class="sourceLine" id="cb22-70" title="70">            t = rotateR (t);</a>
<a class="sourceLine" id="cb22-71" title="71">            t-&gt;colour = BLACK;</a>
<a class="sourceLine" id="cb22-72" title="72">            t-&gt;R-&gt;colour = RED;</a>
<a class="sourceLine" id="cb22-73" title="73">        }</a>
<a class="sourceLine" id="cb22-74" title="74">    } <span class="cf">else</span> <span class="cf">if</span> (diff &gt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb22-75" title="75">        t-&gt;R = insertRB (t-&gt;R, it, <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb22-76" title="76">        <span class="cf">if</span> (isRed (t) &amp;&amp; isRed (t-&gt;R) &amp;&amp; !inRight)</a>
<a class="sourceLine" id="cb22-77" title="77">            t = rotateL (t);</a>
<a class="sourceLine" id="cb22-78" title="78">        <span class="cf">if</span> (isRed (t-&gt;R) &amp;&amp; isRed (t-&gt;R-&gt;R)) {</a>
<a class="sourceLine" id="cb22-79" title="79">            t = rotateL (t);</a>
<a class="sourceLine" id="cb22-80" title="80">            t-&gt;colour = BLACK;</a>
<a class="sourceLine" id="cb22-81" title="81">            t-&gt;L-&gt;colour = RED;</a>
<a class="sourceLine" id="cb22-82" title="82">        }</a>
<a class="sourceLine" id="cb22-83" title="83">    }</a>
<a class="sourceLine" id="cb22-84" title="84">    <span class="cf">return</span> t;</a>
<a class="sourceLine" id="cb22-85" title="85">}</a>
<a class="sourceLine" id="cb22-86" title="86"><span class="co">// other operations as for BSTs</span></a></code></pre></div>
</div>
<h2 id="hash-tables">Hash Tables</h2>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Interface </strong>
</div>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="co">// hashtable.h</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">typedef</span> <span class="kw">struct</span> HashTabRep *HashTable;</a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="co">// create an empty HashTable</span></a>
<a class="sourceLine" id="cb23-5" title="5">HashTable newHashTable(<span class="dt">int</span>);</a>
<a class="sourceLine" id="cb23-6" title="6"><span class="co">// free memory associated with HashTable</span></a>
<a class="sourceLine" id="cb23-7" title="7"><span class="dt">void</span> dropHashTable(HashTable);</a>
<a class="sourceLine" id="cb23-8" title="8"><span class="co">// insert a new value into a HashTable</span></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="dt">void</span> hashTableInsert(HashTable, Item);</a>
<a class="sourceLine" id="cb23-10" title="10"><span class="co">// delete a value from a HashTable</span></a>
<a class="sourceLine" id="cb23-11" title="11"><span class="dt">void</span> hashTableDelete(HashTable, Key);</a>
<a class="sourceLine" id="cb23-12" title="12"><span class="co">// get Item from HashTable using Key</span></a>
<a class="sourceLine" id="cb23-13" title="13">Item *hashTableSearch(HashTable, Key);</a>
<a class="sourceLine" id="cb23-14" title="14"></a>
<a class="sourceLine" id="cb23-15" title="15"><span class="co">// EOF</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Implementation (chains) </strong>
</div>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="pp">#include </span><span class="im">"hashtable.h"</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="pp">#include </span><span class="im">"list.h"</span><span class="pp">  </span><span class="co">// use Lists of Items</span></a>
<a class="sourceLine" id="cb24-3" title="3"></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="kw">typedef</span> <span class="kw">struct</span> HashTabRep {</a>
<a class="sourceLine" id="cb24-5" title="5">    List *lists; <span class="co">// lists of Items</span></a>
<a class="sourceLine" id="cb24-6" title="6">    <span class="dt">int</span> nslots;  <span class="co">// # elements in array</span></a>
<a class="sourceLine" id="cb24-7" title="7">    <span class="dt">int</span> nitems;  <span class="co">// # items stored in HashTable</span></a>
<a class="sourceLine" id="cb24-8" title="8">} HashTabRep;</a>
<a class="sourceLine" id="cb24-9" title="9"></a>
<a class="sourceLine" id="cb24-10" title="10"><span class="co">// convert key to index</span></a>
<a class="sourceLine" id="cb24-11" title="11"><span class="dt">static</span> <span class="dt">int</span> hash (Key k, <span class="dt">int</span> N)</a>
<a class="sourceLine" id="cb24-12" title="12">{</a>
<a class="sourceLine" id="cb24-13" title="13">    <span class="dt">int</span> h = keyhash (k); <span class="co">// convert key to int</span></a>
<a class="sourceLine" id="cb24-14" title="14">    <span class="cf">return</span> h % N;</a>
<a class="sourceLine" id="cb24-15" title="15">}</a>
<a class="sourceLine" id="cb24-16" title="16"></a>
<a class="sourceLine" id="cb24-17" title="17"><span class="co">// create an empty HashTable</span></a>
<a class="sourceLine" id="cb24-18" title="18">HashTable newHashTable (<span class="dt">int</span> N)</a>
<a class="sourceLine" id="cb24-19" title="19">{</a>
<a class="sourceLine" id="cb24-20" title="20">    HashTable new = malloc (<span class="kw">sizeof</span> (HashTable));</a>
<a class="sourceLine" id="cb24-21" title="21">    assert (new != NULL);</a>
<a class="sourceLine" id="cb24-22" title="22">    new-&gt;lists = malloc (N * <span class="kw">sizeof</span> (List));</a>
<a class="sourceLine" id="cb24-23" title="23">    assert (new-&gt;lists != NULL);</a>
<a class="sourceLine" id="cb24-24" title="24">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb24-25" title="25">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; N; i++)</a>
<a class="sourceLine" id="cb24-26" title="26">        new-&gt;lists[i] = newList ();</a>
<a class="sourceLine" id="cb24-27" title="27">    new-&gt;nslots = N;</a>
<a class="sourceLine" id="cb24-28" title="28">    new-&gt;nitems = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb24-29" title="29">    <span class="cf">return</span> new;</a>
<a class="sourceLine" id="cb24-30" title="30">}</a>
<a class="sourceLine" id="cb24-31" title="31"></a>
<a class="sourceLine" id="cb24-32" title="32"><span class="co">// free memory associated with HashTable</span></a>
<a class="sourceLine" id="cb24-33" title="33"><span class="dt">void</span> dropHashTable (HashTable ht)</a>
<a class="sourceLine" id="cb24-34" title="34">{</a>
<a class="sourceLine" id="cb24-35" title="35">    free (ht-&gt;lists);</a>
<a class="sourceLine" id="cb24-36" title="36">    free (ht);</a>
<a class="sourceLine" id="cb24-37" title="37">}</a>
<a class="sourceLine" id="cb24-38" title="38"></a>
<a class="sourceLine" id="cb24-39" title="39"><span class="co">// insert a new value into a HashTable</span></a>
<a class="sourceLine" id="cb24-40" title="40"><span class="dt">void</span> hashTableInsert (HashTable ht, Item it)</a>
<a class="sourceLine" id="cb24-41" title="41">{</a>
<a class="sourceLine" id="cb24-42" title="42">    Key k = key (it);</a>
<a class="sourceLine" id="cb24-43" title="43">    <span class="dt">int</span> i = hash (k, ht-&gt;nslots);</a>
<a class="sourceLine" id="cb24-44" title="44">    ListInsert (ht-&gt;lists[i], it);</a>
<a class="sourceLine" id="cb24-45" title="45">}</a>
<a class="sourceLine" id="cb24-46" title="46"></a>
<a class="sourceLine" id="cb24-47" title="47"><span class="co">// delete a value from a HashTable</span></a>
<a class="sourceLine" id="cb24-48" title="48"><span class="dt">void</span> hashTableDelete (HashTable ht, Key k)</a>
<a class="sourceLine" id="cb24-49" title="49">{</a>
<a class="sourceLine" id="cb24-50" title="50">    <span class="dt">int</span> i = hash (k, ht-&gt;nslots);</a>
<a class="sourceLine" id="cb24-51" title="51">    ListDelete (ht-&gt;lists[i], k);</a>
<a class="sourceLine" id="cb24-52" title="52">}</a>
<a class="sourceLine" id="cb24-53" title="53"></a>
<a class="sourceLine" id="cb24-54" title="54"><span class="co">// get Item from HashTable using Key</span></a>
<a class="sourceLine" id="cb24-55" title="55">Item *hashTableSearch (HashTable ht, Key k)</a>
<a class="sourceLine" id="cb24-56" title="56">{</a>
<a class="sourceLine" id="cb24-57" title="57">    <span class="dt">int</span> i = hash (k, ht-&gt;nslots);</a>
<a class="sourceLine" id="cb24-58" title="58">    <span class="cf">return</span> ListSearch (ht-&gt;lists[i], k);</a>
<a class="sourceLine" id="cb24-59" title="59">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<strong> Implementation (linear probing) </strong>
</div>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="pp">#include </span><span class="im">"hashtable.h"</span></a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">typedef</span> <span class="kw">struct</span> HashTabRep {</a>
<a class="sourceLine" id="cb25-4" title="4">    Item *items; <span class="co">// lists of Items</span></a>
<a class="sourceLine" id="cb25-5" title="5">    <span class="dt">int</span> nslots;  <span class="co">// # elements in array</span></a>
<a class="sourceLine" id="cb25-6" title="6">    <span class="dt">int</span> nitems;  <span class="co">// # items stored in HashTable</span></a>
<a class="sourceLine" id="cb25-7" title="7">} HashTabRep;</a>
<a class="sourceLine" id="cb25-8" title="8"></a>
<a class="sourceLine" id="cb25-9" title="9"><span class="co">// convert key to index</span></a>
<a class="sourceLine" id="cb25-10" title="10"><span class="dt">static</span> <span class="dt">int</span> hash (Key k, <span class="dt">int</span> N)</a>
<a class="sourceLine" id="cb25-11" title="11">{</a>
<a class="sourceLine" id="cb25-12" title="12">    <span class="dt">int</span> h = keyhash (k); <span class="co">// convert key to int</span></a>
<a class="sourceLine" id="cb25-13" title="13">    <span class="cf">return</span> h % N;</a>
<a class="sourceLine" id="cb25-14" title="14">}</a>
<a class="sourceLine" id="cb25-15" title="15"></a>
<a class="sourceLine" id="cb25-16" title="16"><span class="co">// create an empty HashTable</span></a>
<a class="sourceLine" id="cb25-17" title="17">HashTable newHashTable (<span class="dt">int</span> N)</a>
<a class="sourceLine" id="cb25-18" title="18">{</a>
<a class="sourceLine" id="cb25-19" title="19">    HashTabRep *new = malloc (<span class="kw">sizeof</span> (HashTabRep));</a>
<a class="sourceLine" id="cb25-20" title="20">    assert (new != NULL);</a>
<a class="sourceLine" id="cb25-21" title="21">    new-&gt;items = malloc (N * <span class="kw">sizeof</span> (Item));</a>
<a class="sourceLine" id="cb25-22" title="22">    assert (new-&gt;items != NULL);</a>
<a class="sourceLine" id="cb25-23" title="23">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb25-24" title="24">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; N; i++)</a>
<a class="sourceLine" id="cb25-25" title="25">        new-&gt;items[i] = NoItem;</a>
<a class="sourceLine" id="cb25-26" title="26">    new-&gt;nslots = N;</a>
<a class="sourceLine" id="cb25-27" title="27">    new-&gt;nitems = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb25-28" title="28">    <span class="cf">return</span> new;</a>
<a class="sourceLine" id="cb25-29" title="29">}</a>
<a class="sourceLine" id="cb25-30" title="30"></a>
<a class="sourceLine" id="cb25-31" title="31"><span class="co">// free memory associated with HashTable</span></a>
<a class="sourceLine" id="cb25-32" title="32"><span class="dt">void</span> dropHashTable (HashTable ht)</a>
<a class="sourceLine" id="cb25-33" title="33">{</a>
<a class="sourceLine" id="cb25-34" title="34">    free (ht-&gt;items);</a>
<a class="sourceLine" id="cb25-35" title="35">    free (ht);</a>
<a class="sourceLine" id="cb25-36" title="36">}</a>
<a class="sourceLine" id="cb25-37" title="37"></a>
<a class="sourceLine" id="cb25-38" title="38"><span class="co">// insert a new value into a HashTable</span></a>
<a class="sourceLine" id="cb25-39" title="39"><span class="dt">void</span> hashTableInsert (HashTable ht, Item it)</a>
<a class="sourceLine" id="cb25-40" title="40">{</a>
<a class="sourceLine" id="cb25-41" title="41">    <span class="dt">int</span> N = ht-&gt;nslots;</a>
<a class="sourceLine" id="cb25-42" title="42">    Item *data = ht-&gt;items;</a>
<a class="sourceLine" id="cb25-43" title="43">    Key k = key (it);</a>
<a class="sourceLine" id="cb25-44" title="44">    <span class="dt">int</span> ix, j, i = hash (k, N);</a>
<a class="sourceLine" id="cb25-45" title="45">    <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; N; j++) {</a>
<a class="sourceLine" id="cb25-46" title="46">        ix = (i + j) % N;</a>
<a class="sourceLine" id="cb25-47" title="47">        <span class="cf">if</span> (cmp (k, key (data[ix])) == <span class="dv">0</span>) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb25-48" title="48">        <span class="cf">else</span> <span class="cf">if</span> (data[ix] == NoItem) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb25-49" title="49">    }</a>
<a class="sourceLine" id="cb25-50" title="50">    <span class="cf">if</span> (j &lt; N) {</a>
<a class="sourceLine" id="cb25-51" title="51">        data[ix] = it;</a>
<a class="sourceLine" id="cb25-52" title="52">        ht-&gt;nitems++;</a>
<a class="sourceLine" id="cb25-53" title="53">    }</a>
<a class="sourceLine" id="cb25-54" title="54">}</a>
<a class="sourceLine" id="cb25-55" title="55"></a>
<a class="sourceLine" id="cb25-56" title="56"><span class="co">// delete a value from a HashTable</span></a>
<a class="sourceLine" id="cb25-57" title="57"><span class="dt">void</span> hashTableDelete (HashTable ht, Key k)</a>
<a class="sourceLine" id="cb25-58" title="58">{</a>
<a class="sourceLine" id="cb25-59" title="59">    <span class="dt">int</span> N = ht-&gt;nslots;</a>
<a class="sourceLine" id="cb25-60" title="60">    Item *data = ht-&gt;items;</a>
<a class="sourceLine" id="cb25-61" title="61">    <span class="dt">int</span> ix, j, i = hash (k, N);</a>
<a class="sourceLine" id="cb25-62" title="62">    <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; N; j++) {</a>
<a class="sourceLine" id="cb25-63" title="63">        ix = (i + j) % N;</a>
<a class="sourceLine" id="cb25-64" title="64">        <span class="cf">if</span> (cmp (k, key (data[ix])) == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb25-65" title="65">            <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb25-66" title="66">        <span class="cf">else</span> <span class="cf">if</span> (data[ix] == NoItem)</a>
<a class="sourceLine" id="cb25-67" title="67">            <span class="cf">return</span>; <span class="co">// k not in table</span></a>
<a class="sourceLine" id="cb25-68" title="68">    }</a>
<a class="sourceLine" id="cb25-69" title="69">    data[ix] = NoItem;</a>
<a class="sourceLine" id="cb25-70" title="70">    ht-&gt;nitems--;</a>
<a class="sourceLine" id="cb25-71" title="71">    <span class="co">// clean up probe path</span></a>
<a class="sourceLine" id="cb25-72" title="72">    j = ix + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb25-73" title="73">    <span class="cf">while</span> (data[j] != NoItem) {</a>
<a class="sourceLine" id="cb25-74" title="74">        Item it = data[j];</a>
<a class="sourceLine" id="cb25-75" title="75">        data[j] = NoItem;</a>
<a class="sourceLine" id="cb25-76" title="76">        ht-&gt;nitems--;</a>
<a class="sourceLine" id="cb25-77" title="77">        insert (ht, it);</a>
<a class="sourceLine" id="cb25-78" title="78">        j = (j + <span class="dv">1</span>) % N;</a>
<a class="sourceLine" id="cb25-79" title="79">    }</a>
<a class="sourceLine" id="cb25-80" title="80">}</a>
<a class="sourceLine" id="cb25-81" title="81"></a>
<a class="sourceLine" id="cb25-82" title="82"><span class="co">// get Item from HashTable using Key</span></a>
<a class="sourceLine" id="cb25-83" title="83">Item *hashTableSearch (HashTable ht, Key k)</a>
<a class="sourceLine" id="cb25-84" title="84">{</a>
<a class="sourceLine" id="cb25-85" title="85">    <span class="dt">int</span> N = ht-&gt;nslots;</a>
<a class="sourceLine" id="cb25-86" title="86">    Item *data = ht-&gt;items;</a>
<a class="sourceLine" id="cb25-87" title="87">    <span class="dt">int</span> j, i = hash (k, N);</a>
<a class="sourceLine" id="cb25-88" title="88">    <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; N; j++) {</a>
<a class="sourceLine" id="cb25-89" title="89">        <span class="dt">int</span> ix = (i + j) % N;</a>
<a class="sourceLine" id="cb25-90" title="90">        <span class="cf">if</span> (cmp (k, key (data[ix])) == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb25-91" title="91">            <span class="cf">return</span> &amp;(data[ix]);</a>
<a class="sourceLine" id="cb25-92" title="92">    }</a>
<a class="sourceLine" id="cb25-93" title="93">    <span class="cf">return</span> NULL;</a>
<a class="sourceLine" id="cb25-94" title="94">}</a></code></pre></div>
</div>
<h2 id="graphs">Graphs</h2>
<h2 id="graphs-1">Graphs</h2>
<div class="panel panel-default">
<div id="graph" class="panel-heading">
<strong> Interface </strong>
</div>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="co">// graph.h</span></a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="co">// visible data structures for Graphs</span></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="kw">typedef</span> <span class="kw">struct</span> GraphRep *Graph;</a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">// vertices denoted by integers 0..N-1</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="kw">typedef</span> <span class="dt">int</span> Vertex;</a>
<a class="sourceLine" id="cb26-7" title="7"><span class="co">// edges are pairs of vertices (end-points)</span></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="kw">typedef</span> <span class="kw">struct</span> { Vertex v; Vertex w; } Edge;</a>
<a class="sourceLine" id="cb26-9" title="9"><span class="co">// auxiliary operations on graphs</span></a>
<a class="sourceLine" id="cb26-10" title="10"><span class="dt">int</span> validV(Graph,Vertex); <span class="co">// validity check</span></a>
<a class="sourceLine" id="cb26-11" title="11">Edge mkEdge(Graph, Vertex, Vertex); <span class="co">// edge creation</span></a>
<a class="sourceLine" id="cb26-12" title="12"><span class="dt">int</span> neighbours(Graph, Vertex, Vertex); <span class="co">// edge existence</span></a>
<a class="sourceLine" id="cb26-13" title="13"><span class="co">// core operations on graphs</span></a>
<a class="sourceLine" id="cb26-14" title="14"><span class="co">// make new graph with nV vertices</span></a>
<a class="sourceLine" id="cb26-15" title="15">Graph newGraph(<span class="dt">int</span> nV);</a>
<a class="sourceLine" id="cb26-16" title="16"><span class="co">// free memory allocated to graph</span></a>
<a class="sourceLine" id="cb26-17" title="17"><span class="dt">void</span> dropGraph(Graph);</a>
<a class="sourceLine" id="cb26-18" title="18"><span class="co">// show "printable" representation of graph</span></a>
<a class="sourceLine" id="cb26-19" title="19"><span class="dt">void</span> showGraph(Graph);</a>
<a class="sourceLine" id="cb26-20" title="20"><span class="co">// add new edge to a graph</span></a>
<a class="sourceLine" id="cb26-21" title="21"><span class="dt">void</span> insertE(Graph, Edge);</a>
<a class="sourceLine" id="cb26-22" title="22"><span class="co">// remove an edge from a graph</span></a>
<a class="sourceLine" id="cb26-23" title="23"><span class="dt">void</span> removeE(Graph, Edge);</a>
<a class="sourceLine" id="cb26-24" title="24"><span class="co">// returns #vertices &amp; array of edges</span></a>
<a class="sourceLine" id="cb26-25" title="25"><span class="dt">int</span> edges(Graph, Edge *, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb26-26" title="26"></a>
<a class="sourceLine" id="cb26-27" title="27"><span class="co">// EOF</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="graph-aux" class="panel-heading">
<strong> Auxiliary Operations </strong>
</div>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1"><span class="pp">#include </span><span class="im">"graph.h"</span></a>
<a class="sourceLine" id="cb27-2" title="2"></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="co">// is a vertex valid in a given Graph?</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="dt">int</span> validV (Graph g, Vertex v)</a>
<a class="sourceLine" id="cb27-5" title="5">{</a>
<a class="sourceLine" id="cb27-6" title="6">    <span class="cf">return</span> (g != NULL &amp;&amp; v &gt;= <span class="dv">0</span> &amp;&amp; v &lt; g-&gt;nV);</a>
<a class="sourceLine" id="cb27-7" title="7">}</a>
<a class="sourceLine" id="cb27-8" title="8"><span class="co">// make an Edge value</span></a>
<a class="sourceLine" id="cb27-9" title="9">Edge mkEdge (Graph g, Vertex v, Vertex w)</a>
<a class="sourceLine" id="cb27-10" title="10">{</a>
<a class="sourceLine" id="cb27-11" title="11">    assert (validV (g, v) &amp;&amp; validV (g, w));</a>
<a class="sourceLine" id="cb27-12" title="12">    Edge e = {v, w}; <span class="co">// struct assignment</span></a>
<a class="sourceLine" id="cb27-13" title="13">    <span class="cf">return</span> e;</a>
<a class="sourceLine" id="cb27-14" title="14">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="graph-adjmatrix" class="panel-heading">
<strong> Adjacency Matrix Implementation </strong>
</div>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="co">// graph_adjmatrix.c</span></a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="kw">typedef</span> <span class="kw">struct</span> GraphRep {</a>
<a class="sourceLine" id="cb28-4" title="4">    <span class="dt">int</span> nV;       <span class="co">// #vertices</span></a>
<a class="sourceLine" id="cb28-5" title="5">    <span class="dt">int</span> nE;       <span class="co">// #edges</span></a>
<a class="sourceLine" id="cb28-6" title="6">    <span class="dt">bool</span> **edges; <span class="co">// matrix of booleans</span></a>
<a class="sourceLine" id="cb28-7" title="7">} GraphRep;</a>
<a class="sourceLine" id="cb28-8" title="8"></a>
<a class="sourceLine" id="cb28-9" title="9"><span class="co">// check whether two vertices are connected</span></a>
<a class="sourceLine" id="cb28-10" title="10"><span class="dt">int</span> neighbours (Graph g, Vertex v, Vertex w)</a>
<a class="sourceLine" id="cb28-11" title="11">{</a>
<a class="sourceLine" id="cb28-12" title="12">    assert (validV (g, v) &amp;&amp; validV (g, w));</a>
<a class="sourceLine" id="cb28-13" title="13">    <span class="cf">return</span> g-&gt;edges[v][w];</a>
<a class="sourceLine" id="cb28-14" title="14">}</a>
<a class="sourceLine" id="cb28-15" title="15"></a>
<a class="sourceLine" id="cb28-16" title="16"><span class="co">// make new graph with nV vertices</span></a>
<a class="sourceLine" id="cb28-17" title="17">Graph newGraph (<span class="dt">int</span> nV)</a>
<a class="sourceLine" id="cb28-18" title="18">{</a>
<a class="sourceLine" id="cb28-19" title="19">    assert (nV &gt;= <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb28-20" title="20">    Graph g = malloc (<span class="kw">sizeof</span> (GraphRep));</a>
<a class="sourceLine" id="cb28-21" title="21">    g-&gt;nV = nV;</a>
<a class="sourceLine" id="cb28-22" title="22">    g-&gt;nE = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb28-23" title="23">    g-&gt;edges = malloc (nV * <span class="kw">sizeof</span> (<span class="dt">bool</span> *));</a>
<a class="sourceLine" id="cb28-24" title="24">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; nV; i++) {</a>
<a class="sourceLine" id="cb28-25" title="25">        g-&gt;edges[i] = malloc (nV * <span class="kw">sizeof</span> (<span class="dt">bool</span>));</a>
<a class="sourceLine" id="cb28-26" title="26">        <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; nV; j++)</a>
<a class="sourceLine" id="cb28-27" title="27">            g-&gt;edges[i][j] = false;</a>
<a class="sourceLine" id="cb28-28" title="28">    }</a>
<a class="sourceLine" id="cb28-29" title="29">    <span class="cf">return</span> g;</a>
<a class="sourceLine" id="cb28-30" title="30">}</a>
<a class="sourceLine" id="cb28-31" title="31"></a>
<a class="sourceLine" id="cb28-32" title="32"><span class="co">// free memory allocated to graph</span></a>
<a class="sourceLine" id="cb28-33" title="33"><span class="dt">void</span> dropGraph (Graph g)</a>
<a class="sourceLine" id="cb28-34" title="34">{</a>
<a class="sourceLine" id="cb28-35" title="35">    assert (g != NULL);</a>
<a class="sourceLine" id="cb28-36" title="36">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb28-37" title="37">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++)</a>
<a class="sourceLine" id="cb28-38" title="38">        free (g-&gt;edges[i]);</a>
<a class="sourceLine" id="cb28-39" title="39">    free (g-&gt;edges);</a>
<a class="sourceLine" id="cb28-40" title="40">    free (g);</a>
<a class="sourceLine" id="cb28-41" title="41">}</a>
<a class="sourceLine" id="cb28-42" title="42"></a>
<a class="sourceLine" id="cb28-43" title="43"><span class="co">// show "printable" representation of graph</span></a>
<a class="sourceLine" id="cb28-44" title="44"><span class="dt">void</span> showGraph (Graph g)</a>
<a class="sourceLine" id="cb28-45" title="45">{</a>
<a class="sourceLine" id="cb28-46" title="46">    assert (g != NULL);</a>
<a class="sourceLine" id="cb28-47" title="47">    printf (<span class="st">"V=%d, E=%d</span><span class="sc">\n</span><span class="st">"</span>, g-&gt;nV, g-&gt;nE);</a>
<a class="sourceLine" id="cb28-48" title="48">    <span class="dt">int</span> i, j;</a>
<a class="sourceLine" id="cb28-49" title="49">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++) {</a>
<a class="sourceLine" id="cb28-50" title="50">        <span class="dt">int</span> nshown = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb28-51" title="51">        <span class="cf">for</span> (j = i + <span class="dv">1</span>; j &lt; g-&gt;nV; j++) {</a>
<a class="sourceLine" id="cb28-52" title="52">            <span class="cf">if</span> (g-&gt;edges[i][j] != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb28-53" title="53">                printf (<span class="st">"%d-%d "</span>, i, j);</a>
<a class="sourceLine" id="cb28-54" title="54">                nshown++;</a>
<a class="sourceLine" id="cb28-55" title="55">            }</a>
<a class="sourceLine" id="cb28-56" title="56">        }</a>
<a class="sourceLine" id="cb28-57" title="57">        <span class="cf">if</span> (nshown &gt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb28-58" title="58">            printf (<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>);</a>
<a class="sourceLine" id="cb28-59" title="59">    }</a>
<a class="sourceLine" id="cb28-60" title="60">}</a>
<a class="sourceLine" id="cb28-61" title="61"></a>
<a class="sourceLine" id="cb28-62" title="62"><span class="co">// add new edge to a graph</span></a>
<a class="sourceLine" id="cb28-63" title="63"><span class="dt">void</span> insertE (Graph g, Edge e)</a>
<a class="sourceLine" id="cb28-64" title="64">{</a>
<a class="sourceLine" id="cb28-65" title="65">    assert (g != NULL);</a>
<a class="sourceLine" id="cb28-66" title="66">    assert (validV (g, e.v) &amp;&amp; validV (g, e.w));</a>
<a class="sourceLine" id="cb28-67" title="67">    <span class="cf">if</span> (g-&gt;edges[e.v][e.w])</a>
<a class="sourceLine" id="cb28-68" title="68">        <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb28-69" title="69">    g-&gt;edges[e.v][e.w] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb28-70" title="70">    g-&gt;edges[e.w][e.v] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb28-71" title="71">    g-&gt;nE++;</a>
<a class="sourceLine" id="cb28-72" title="72">}</a>
<a class="sourceLine" id="cb28-73" title="73"></a>
<a class="sourceLine" id="cb28-74" title="74"><span class="co">// remove an edge from a graph</span></a>
<a class="sourceLine" id="cb28-75" title="75"><span class="dt">void</span> removeE (Graph g, Edge e)</a>
<a class="sourceLine" id="cb28-76" title="76">{</a>
<a class="sourceLine" id="cb28-77" title="77">    assert (g != NULL);</a>
<a class="sourceLine" id="cb28-78" title="78">    assert (validV (g, e.v) &amp;&amp; validV (g, e.w));</a>
<a class="sourceLine" id="cb28-79" title="79">    <span class="cf">if</span> (!g-&gt;edges[e.v][e.w])</a>
<a class="sourceLine" id="cb28-80" title="80">        <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb28-81" title="81">    g-&gt;edges[e.v][e.w] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb28-82" title="82">    g-&gt;edges[e.w][e.v] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb28-83" title="83">    g-&gt;nE--;</a>
<a class="sourceLine" id="cb28-84" title="84">}</a>
<a class="sourceLine" id="cb28-85" title="85"></a>
<a class="sourceLine" id="cb28-86" title="86"><span class="co">// returns #vertices &amp; array of edges</span></a>
<a class="sourceLine" id="cb28-87" title="87"><span class="dt">int</span> edges (Graph g, Edge *es, <span class="dt">int</span> nE)</a>
<a class="sourceLine" id="cb28-88" title="88">{</a>
<a class="sourceLine" id="cb28-89" title="89">    assert (g != NULL &amp;&amp; es != NULL);</a>
<a class="sourceLine" id="cb28-90" title="90">    assert (nE &gt;= g-&gt;nE);</a>
<a class="sourceLine" id="cb28-91" title="91">    <span class="dt">int</span> i, j, n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb28-92" title="92">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++) {</a>
<a class="sourceLine" id="cb28-93" title="93">        <span class="cf">for</span> (j = i + <span class="dv">1</span>; j &lt; g-&gt;nV; j++) {</a>
<a class="sourceLine" id="cb28-94" title="94">            <span class="cf">if</span> (g-&gt;edges[i][j] != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb28-95" title="95">                assert (n &lt; nE);</a>
<a class="sourceLine" id="cb28-96" title="96">                es[n++] = mkEdge (g, i, j);</a>
<a class="sourceLine" id="cb28-97" title="97">            }</a>
<a class="sourceLine" id="cb28-98" title="98">        }</a>
<a class="sourceLine" id="cb28-99" title="99">    }</a>
<a class="sourceLine" id="cb28-100" title="100">    <span class="cf">return</span> n;</a>
<a class="sourceLine" id="cb28-101" title="101">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="graph-adjlist" class="panel-heading">
<strong> Adjacency List Implementation </strong>
</div>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="co">// graph_adjmatrix.c</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="kw">typedef</span> <span class="kw">struct</span> vNode *VList;</a>
<a class="sourceLine" id="cb29-4" title="4"><span class="kw">struct</span> vNode { Vertex v; VList next; };</a>
<a class="sourceLine" id="cb29-5" title="5">VList insertVList (VList, Vertex);</a>
<a class="sourceLine" id="cb29-6" title="6">VList deleteVList (VList, Vertex);</a>
<a class="sourceLine" id="cb29-7" title="7"><span class="dt">void</span> freeVList (VList);</a>
<a class="sourceLine" id="cb29-8" title="8"><span class="dt">int</span> length (VList);</a>
<a class="sourceLine" id="cb29-9" title="9"><span class="kw">struct</span> GraphRep {</a>
<a class="sourceLine" id="cb29-10" title="10">    <span class="dt">int</span> nV;       <span class="co">// #vertices</span></a>
<a class="sourceLine" id="cb29-11" title="11">    <span class="dt">int</span> nE;       <span class="co">// #edges</span></a>
<a class="sourceLine" id="cb29-12" title="12">    VList *edges; <span class="co">// array of lists</span></a>
<a class="sourceLine" id="cb29-13" title="13">};</a>
<a class="sourceLine" id="cb29-14" title="14"></a>
<a class="sourceLine" id="cb29-15" title="15"><span class="co">// check whether two vertices are connected</span></a>
<a class="sourceLine" id="cb29-16" title="16"><span class="dt">int</span> neighbours (Graph g, Vertex v, Vertex w)</a>
<a class="sourceLine" id="cb29-17" title="17">{</a>
<a class="sourceLine" id="cb29-18" title="18">    assert (validV (g, v) &amp;&amp; validV (g, w));</a>
<a class="sourceLine" id="cb29-19" title="19">    VList curr;</a>
<a class="sourceLine" id="cb29-20" title="20">    curr = g-&gt;edges[v];</a>
<a class="sourceLine" id="cb29-21" title="21">    <span class="cf">while</span> (curr != NULL) {</a>
<a class="sourceLine" id="cb29-22" title="22">        <span class="cf">if</span> (curr-&gt;v == w)</a>
<a class="sourceLine" id="cb29-23" title="23">            <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb29-24" title="24">    }</a>
<a class="sourceLine" id="cb29-25" title="25">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb29-26" title="26">}</a>
<a class="sourceLine" id="cb29-27" title="27"><span class="co">// make new graph with nV vertices</span></a>
<a class="sourceLine" id="cb29-28" title="28">Graph newGraph (<span class="dt">int</span> nV)</a>
<a class="sourceLine" id="cb29-29" title="29">{</a>
<a class="sourceLine" id="cb29-30" title="30">    Graph g = malloc (<span class="kw">sizeof</span> (<span class="kw">struct</span> GraphRep));</a>
<a class="sourceLine" id="cb29-31" title="31">    g-&gt;nV = nV;</a>
<a class="sourceLine" id="cb29-32" title="32">    g-&gt;nE = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb29-33" title="33">    g-&gt;edges = calloc (nV, <span class="kw">sizeof</span> (VList));</a>
<a class="sourceLine" id="cb29-34" title="34">    <span class="cf">return</span> g;</a>
<a class="sourceLine" id="cb29-35" title="35">}</a>
<a class="sourceLine" id="cb29-36" title="36"></a>
<a class="sourceLine" id="cb29-37" title="37"><span class="co">// free memory allocated to graph</span></a>
<a class="sourceLine" id="cb29-38" title="38"><span class="dt">void</span> dropGraph (Graph g)</a>
<a class="sourceLine" id="cb29-39" title="39">{</a>
<a class="sourceLine" id="cb29-40" title="40">    assert (g != NULL);</a>
<a class="sourceLine" id="cb29-41" title="41">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb29-42" title="42">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++)</a>
<a class="sourceLine" id="cb29-43" title="43">        freeVList (g-&gt;edges[i]);</a>
<a class="sourceLine" id="cb29-44" title="44">    free (g);</a>
<a class="sourceLine" id="cb29-45" title="45">}</a>
<a class="sourceLine" id="cb29-46" title="46"></a>
<a class="sourceLine" id="cb29-47" title="47"><span class="co">// show "printable" representation of graph</span></a>
<a class="sourceLine" id="cb29-48" title="48"><span class="dt">void</span> showGraph (Graph g)</a>
<a class="sourceLine" id="cb29-49" title="49">{</a>
<a class="sourceLine" id="cb29-50" title="50">    assert (g != NULL);</a>
<a class="sourceLine" id="cb29-51" title="51">    printf (<span class="st">"V=%d, E=%d</span><span class="sc">\n</span><span class="st">"</span>, g-&gt;nV, g-&gt;nE);</a>
<a class="sourceLine" id="cb29-52" title="52">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb29-53" title="53">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++) {</a>
<a class="sourceLine" id="cb29-54" title="54">        <span class="kw">struct</span> vNode *n = g-&gt;edges[i];</a>
<a class="sourceLine" id="cb29-55" title="55">        <span class="cf">while</span> (n != NULL) {</a>
<a class="sourceLine" id="cb29-56" title="56">            printf (<span class="st">"%d-%d "</span>, i, n-&gt;v);</a>
<a class="sourceLine" id="cb29-57" title="57">            n = n-&gt;next;</a>
<a class="sourceLine" id="cb29-58" title="58">        }</a>
<a class="sourceLine" id="cb29-59" title="59">        <span class="cf">if</span> (g-&gt;edges[i] != NULL)</a>
<a class="sourceLine" id="cb29-60" title="60">            printf (<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>);</a>
<a class="sourceLine" id="cb29-61" title="61">    }</a>
<a class="sourceLine" id="cb29-62" title="62">}</a>
<a class="sourceLine" id="cb29-63" title="63"></a>
<a class="sourceLine" id="cb29-64" title="64"><span class="co">// add new edge to a graph</span></a>
<a class="sourceLine" id="cb29-65" title="65"><span class="dt">void</span> insertE (Graph g, Edge e)</a>
<a class="sourceLine" id="cb29-66" title="66">{</a>
<a class="sourceLine" id="cb29-67" title="67">    assert (g != NULL);</a>
<a class="sourceLine" id="cb29-68" title="68">    assert (validV (g, e.v) &amp;&amp; validV (g, e.w));</a>
<a class="sourceLine" id="cb29-69" title="69">    <span class="dt">int</span> orig = length (g-&gt;edges[e.v]);</a>
<a class="sourceLine" id="cb29-70" title="70">    g-&gt;edges[e.v] = insertVList (g-&gt;edges[e.v], e.w);</a>
<a class="sourceLine" id="cb29-71" title="71">    g-&gt;edges[e.w] = insertVList (g-&gt;edges[e.w], e.v);</a>
<a class="sourceLine" id="cb29-72" title="72">    <span class="cf">if</span> (length (g-&gt;edges[e.v]) &gt; orig)</a>
<a class="sourceLine" id="cb29-73" title="73">        g-&gt;nE++;</a>
<a class="sourceLine" id="cb29-74" title="74">}</a>
<a class="sourceLine" id="cb29-75" title="75"></a>
<a class="sourceLine" id="cb29-76" title="76"><span class="co">// remove an edge from a graph</span></a>
<a class="sourceLine" id="cb29-77" title="77"><span class="dt">void</span> removeE (Graph g, Edge e)</a>
<a class="sourceLine" id="cb29-78" title="78">{</a>
<a class="sourceLine" id="cb29-79" title="79">    assert (g != NULL);</a>
<a class="sourceLine" id="cb29-80" title="80">    assert (validV (g, e.v) &amp;&amp; validV (g, e.w));</a>
<a class="sourceLine" id="cb29-81" title="81">    <span class="dt">int</span> orig = length (g-&gt;edges[e.v]);</a>
<a class="sourceLine" id="cb29-82" title="82">    g-&gt;edges[e.v] = deleteVList (g-&gt;edges[e.v], e.w);</a>
<a class="sourceLine" id="cb29-83" title="83">    g-&gt;edges[e.w] = deleteVList (g-&gt;edges[e.w], e.v);</a>
<a class="sourceLine" id="cb29-84" title="84">    <span class="cf">if</span> (length (g-&gt;edges[e.v]) &lt; orig)</a>
<a class="sourceLine" id="cb29-85" title="85">        g-&gt;nE--;</a>
<a class="sourceLine" id="cb29-86" title="86">}</a>
<a class="sourceLine" id="cb29-87" title="87"></a>
<a class="sourceLine" id="cb29-88" title="88"><span class="co">// returns #vertices &amp; array of edges</span></a>
<a class="sourceLine" id="cb29-89" title="89"><span class="dt">int</span> edges (Graph g, Edge *es, <span class="dt">int</span> nE)</a>
<a class="sourceLine" id="cb29-90" title="90">{</a>
<a class="sourceLine" id="cb29-91" title="91">    VList curr;</a>
<a class="sourceLine" id="cb29-92" title="92">    assert (g != NULL &amp;&amp; es != NULL);</a>
<a class="sourceLine" id="cb29-93" title="93">    assert (nE &gt;= g-&gt;nE);</a>
<a class="sourceLine" id="cb29-94" title="94">    <span class="dt">int</span> w, n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb29-95" title="95">    <span class="cf">for</span> (w = <span class="dv">0</span>; w &lt; g-&gt;nV; w++) {</a>
<a class="sourceLine" id="cb29-96" title="96">        curr = g-&gt;edges[w];</a>
<a class="sourceLine" id="cb29-97" title="97">        <span class="cf">while</span> (curr != NULL) {</a>
<a class="sourceLine" id="cb29-98" title="98">            <span class="cf">if</span> (w &lt; curr-&gt;v)</a>
<a class="sourceLine" id="cb29-99" title="99">                es[n++] = mkEdge (g, w, curr-&gt;v);</a>
<a class="sourceLine" id="cb29-100" title="100">            curr = curr-&gt;next;</a>
<a class="sourceLine" id="cb29-101" title="101">        }</a>
<a class="sourceLine" id="cb29-102" title="102">    }</a>
<a class="sourceLine" id="cb29-103" title="103">    <span class="cf">return</span> n;</a>
<a class="sourceLine" id="cb29-104" title="104">}</a></code></pre></div>
</div>
<p>}}</p>
<h2 id="traversal">Traversal</h2>
<div class="panel panel-default">
<div id="graph-haspath" class="panel-heading">
<strong> Path Checking </strong>
</div>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="co">// to your chosen graph implementation, add:</span></a>
<a class="sourceLine" id="cb30-2" title="2"></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="dt">bool</span> *visited;  <span class="co">// array of booleans</span></a>
<a class="sourceLine" id="cb30-4" title="4">               <span class="co">// indexed by vertex 0..V-1</span></a>
<a class="sourceLine" id="cb30-5" title="5"></a>
<a class="sourceLine" id="cb30-6" title="6"><span class="co">// DFS : depth-first search</span></a>
<a class="sourceLine" id="cb30-7" title="7"><span class="dt">int</span> hasPathDFS (Graph g, Vertex src, Vertex dest)</a>
<a class="sourceLine" id="cb30-8" title="8">{</a>
<a class="sourceLine" id="cb30-9" title="9">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb30-10" title="10">    visited = malloc (g-&gt;nV * <span class="kw">sizeof</span> (<span class="dt">bool</span>));</a>
<a class="sourceLine" id="cb30-11" title="11">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++)</a>
<a class="sourceLine" id="cb30-12" title="12">        visited[i] = false;</a>
<a class="sourceLine" id="cb30-13" title="13">    <span class="cf">return</span> dfsPathCheck (g, src, dest);</a>
<a class="sourceLine" id="cb30-14" title="14">}</a>
<a class="sourceLine" id="cb30-15" title="15"></a>
<a class="sourceLine" id="cb30-16" title="16"><span class="dt">int</span> dfsPathCheck (Graph g, Vertex v, Vertex dest)</a>
<a class="sourceLine" id="cb30-17" title="17">{</a>
<a class="sourceLine" id="cb30-18" title="18">    visited[v] = true;</a>
<a class="sourceLine" id="cb30-19" title="19">    Vertex w;</a>
<a class="sourceLine" id="cb30-20" title="20">    <span class="cf">for</span> (w = <span class="dv">0</span>; w &lt; g-&gt;nV; w++) {</a>
<a class="sourceLine" id="cb30-21" title="21">        <span class="cf">if</span> (g-&gt;edges[v][w] &amp;&amp; w == dest)</a>
<a class="sourceLine" id="cb30-22" title="22">            <span class="cf">return</span> <span class="dv">1</span>; <span class="co">// found path</span></a>
<a class="sourceLine" id="cb30-23" title="23">        <span class="cf">if</span> (g-&gt;edges[v][w] &amp;&amp; !visited[w])</a>
<a class="sourceLine" id="cb30-24" title="24">            <span class="cf">return</span> dfsPathCheck (g, w, dest);</a>
<a class="sourceLine" id="cb30-25" title="25">    }</a>
<a class="sourceLine" id="cb30-26" title="26">    <span class="cf">return</span> <span class="dv">0</span>; <span class="co">// no path from src to dest</span></a>
<a class="sourceLine" id="cb30-27" title="27">}</a>
<a class="sourceLine" id="cb30-28" title="28"></a>
<a class="sourceLine" id="cb30-29" title="29"><span class="co">// BFS : breadth-first search</span></a>
<a class="sourceLine" id="cb30-30" title="30"><span class="dt">int</span> hasPathBFS (Graph g, Vertex src, Vertex dest)</a>
<a class="sourceLine" id="cb30-31" title="31">{</a>
<a class="sourceLine" id="cb30-32" title="32">    <span class="dt">int</span> *visited = calloc (g-&gt;nV, <span class="kw">sizeof</span> (<span class="dt">bool</span>));</a>
<a class="sourceLine" id="cb30-33" title="33">    Queue q = newQueue (g-&gt;nV);</a>
<a class="sourceLine" id="cb30-34" title="34">    QueueJoin (q, src);</a>
<a class="sourceLine" id="cb30-35" title="35">    <span class="dt">int</span> isFound = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb30-36" title="36">    <span class="cf">while</span> (!QueueIsEmpty (q) &amp;&amp; !isFound) {</a>
<a class="sourceLine" id="cb30-37" title="37">        Vertex y, x = QueueLeave (q);</a>
<a class="sourceLine" id="cb30-38" title="38">        <span class="cf">if</span> (visited[x]) <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb30-39" title="39">        visited[x] = true;</a>
<a class="sourceLine" id="cb30-40" title="40">        <span class="cf">for</span> (y = <span class="dv">0</span>; y &lt; g-&gt;nV; y++) {</a>
<a class="sourceLine" id="cb30-41" title="41">            <span class="cf">if</span> (!g-&gt;edges[x][y]) <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb30-42" title="42">            <span class="cf">if</span> (y == dest) {</a>
<a class="sourceLine" id="cb30-43" title="43">                isFound = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb30-44" title="44">                <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb30-45" title="45">            }</a>
<a class="sourceLine" id="cb30-46" title="46">            <span class="cf">if</span> (!visited[y]) {</a>
<a class="sourceLine" id="cb30-47" title="47">                QueueJoin (q, y);</a>
<a class="sourceLine" id="cb30-48" title="48">            }</a>
<a class="sourceLine" id="cb30-49" title="49">        }</a>
<a class="sourceLine" id="cb30-50" title="50">    }</a>
<a class="sourceLine" id="cb30-51" title="51">    free (visited);</a>
<a class="sourceLine" id="cb30-52" title="52">    <span class="cf">return</span> isFound;</a>
<a class="sourceLine" id="cb30-53" title="53">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="graph-findpath" class="panel-heading">
<strong> Find and Display Shortest Path </strong>
</div>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="co">// to your chosen graph implementation, add:</span></a>
<a class="sourceLine" id="cb31-2" title="2"></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="dt">int</span></a>
<a class="sourceLine" id="cb31-4" title="4">findPath (Graph g, Vertex src, Vertex dest)</a>
<a class="sourceLine" id="cb31-5" title="5">{</a>
<a class="sourceLine" id="cb31-6" title="6">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb31-7" title="7">    <span class="co">// array of "been visited" flags</span></a>
<a class="sourceLine" id="cb31-8" title="8">    <span class="dt">int</span> *visited = malloc (g-&gt;nV * <span class="kw">sizeof</span> (<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb31-9" title="9">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++) visited[i] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb31-10" title="10">    <span class="co">// array of path predecessor vertices</span></a>
<a class="sourceLine" id="cb31-11" title="11">    Vertex *path = malloc (g-&gt;nV * <span class="kw">sizeof</span> (Vertex));</a>
<a class="sourceLine" id="cb31-12" title="12">    Queue q = newQueue (g-&gt;nV);</a>
<a class="sourceLine" id="cb31-13" title="13">    QueueJoin (q, src);</a>
<a class="sourceLine" id="cb31-14" title="14">    visited[src] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb31-15" title="15">    <span class="dt">int</span> isFound = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb31-16" title="16">    <span class="cf">while</span> (!QueueIsEmpty (q) &amp;&amp; !isFound) {</a>
<a class="sourceLine" id="cb31-17" title="17">        Vertex y, x = QueueLeave (q);</a>
<a class="sourceLine" id="cb31-18" title="18">        <span class="cf">for</span> (y = <span class="dv">0</span>; y &lt; g-&gt;nV; y++) {</a>
<a class="sourceLine" id="cb31-19" title="19">            <span class="cf">if</span> (!g-&gt;edges[x][y]) <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb31-20" title="20">            path[y] = x;</a>
<a class="sourceLine" id="cb31-21" title="21">            <span class="cf">if</span> (y == dest) {</a>
<a class="sourceLine" id="cb31-22" title="22">                isFound = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb31-23" title="23">                <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb31-24" title="24">            }</a>
<a class="sourceLine" id="cb31-25" title="25">            <span class="cf">if</span> (!visited[y]) {</a>
<a class="sourceLine" id="cb31-26" title="26">                QueueJoin (q, y);</a>
<a class="sourceLine" id="cb31-27" title="27">                visited[y] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb31-28" title="28">            }</a>
<a class="sourceLine" id="cb31-29" title="29">        }</a>
<a class="sourceLine" id="cb31-30" title="30">    }</a>
<a class="sourceLine" id="cb31-31" title="31">    <span class="cf">if</span> (isFound) {</a>
<a class="sourceLine" id="cb31-32" title="32">        <span class="co">// display path in dest..src order</span></a>
<a class="sourceLine" id="cb31-33" title="33">        Vertex v;</a>
<a class="sourceLine" id="cb31-34" title="34">        <span class="cf">for</span> (v = dest; v != src; v = path[v])</a>
<a class="sourceLine" id="cb31-35" title="35">            printf (<span class="st">"%d&lt;-"</span>, v);</a>
<a class="sourceLine" id="cb31-36" title="36">        printf (<span class="st">"%d</span><span class="sc">\n</span><span class="st">"</span>, src);</a>
<a class="sourceLine" id="cb31-37" title="37">    }</a>
<a class="sourceLine" id="cb31-38" title="38"></a>
<a class="sourceLine" id="cb31-39" title="39">    <span class="cf">return</span> isFound;</a>
<a class="sourceLine" id="cb31-40" title="40">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="graph-components" class="panel-heading">
<strong> Connected Components </strong>
</div>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="co">// to your chosen graph implementation, add:</span></a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="dt">int</span> *componentOf;  <span class="co">// array of component ids</span></a>
<a class="sourceLine" id="cb32-4" title="4">                   <span class="co">// indexed by vertex 0..V-1</span></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="dt">int</span> ncounted;      <span class="co">// # vertices included so far</span></a>
<a class="sourceLine" id="cb32-6" title="6"></a>
<a class="sourceLine" id="cb32-7" title="7"><span class="dt">void</span> components (Graph g)</a>
<a class="sourceLine" id="cb32-8" title="8">{</a>
<a class="sourceLine" id="cb32-9" title="9">    <span class="dt">void</span> dfsComponents (Graph, Vertex, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb32-10" title="10">    <span class="dt">int</span> i, comp = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb32-11" title="11">    componentOf = malloc (g-&gt;nV * <span class="kw">sizeof</span> (<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb32-12" title="12">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++)</a>
<a class="sourceLine" id="cb32-13" title="13">        componentOf[i] = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb32-14" title="14">    ncounted = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb32-15" title="15">    <span class="cf">while</span> (ncounted &lt; g-&gt;nV) {</a>
<a class="sourceLine" id="cb32-16" title="16">        Vertex v;</a>
<a class="sourceLine" id="cb32-17" title="17">        <span class="cf">for</span> (v = <span class="dv">0</span>; v &lt; g-&gt;nV; v++)</a>
<a class="sourceLine" id="cb32-18" title="18">            <span class="cf">if</span> (componentOf[v] == <span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb32-19" title="19">                <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb32-20" title="20">        dfsComponents (g, v, comp);</a>
<a class="sourceLine" id="cb32-21" title="21">        comp++;</a>
<a class="sourceLine" id="cb32-22" title="22">    }</a>
<a class="sourceLine" id="cb32-23" title="23">    <span class="co">// componentOf[] is now set</span></a>
<a class="sourceLine" id="cb32-24" title="24">}</a>
<a class="sourceLine" id="cb32-25" title="25"></a>
<a class="sourceLine" id="cb32-26" title="26"><span class="dt">void</span> dfsComponents (Graph g, Vertex v, <span class="dt">int</span> c)</a>
<a class="sourceLine" id="cb32-27" title="27">{</a>
<a class="sourceLine" id="cb32-28" title="28">    componentOf[v] = c;</a>
<a class="sourceLine" id="cb32-29" title="29">    ncounted++;</a>
<a class="sourceLine" id="cb32-30" title="30">    Vertex w;</a>
<a class="sourceLine" id="cb32-31" title="31">    <span class="cf">for</span> (w = <span class="dv">0</span>; w &lt; g-&gt;nV; w++) {</a>
<a class="sourceLine" id="cb32-32" title="32">        <span class="cf">if</span> (g-&gt;edges[v][w] &amp;&amp; componentOf[w] == <span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb32-33" title="33">            dfsComponents (g, w, c);</a>
<a class="sourceLine" id="cb32-34" title="34">    }</a>
<a class="sourceLine" id="cb32-35" title="35">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="graph-hamilton" class="panel-heading">
<strong> Hamilton Path Check </strong>
</div>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="co">// to your chosen graph implementation, add:</span></a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="dt">int</span> *visited; <span class="co">// array of nV bools</span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="dt">int</span> HamiltonR (Graph g, Vertex v, Vertex w, <span class="dt">int</span> d)</a>
<a class="sourceLine" id="cb33-5" title="5">{</a>
<a class="sourceLine" id="cb33-6" title="6">    <span class="dt">int</span> t;</a>
<a class="sourceLine" id="cb33-7" title="7">    <span class="cf">if</span> (v == w) <span class="cf">return</span> (d == <span class="dv">0</span>) ? <span class="dv">1</span> : <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb33-8" title="8">    visited[v] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-9" title="9">    <span class="cf">for</span> (t = <span class="dv">0</span>; t &lt; g-&gt;nV; t++) {</a>
<a class="sourceLine" id="cb33-10" title="10">        <span class="cf">if</span> (!neighbours (g, v, t)) <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb33-11" title="11">        <span class="cf">if</span> (visited[v] == <span class="dv">1</span>) <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb33-12" title="12">        <span class="cf">if</span> (HamiltonR (g, t, w, d - <span class="dv">1</span>)) <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-13" title="13">    }</a>
<a class="sourceLine" id="cb33-14" title="14">    visited[v] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb33-15" title="15">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb33-16" title="16">}</a>
<a class="sourceLine" id="cb33-17" title="17"></a>
<a class="sourceLine" id="cb33-18" title="18"><span class="dt">int</span> hasHamiltonPath (Graph g, Vertex src, Vertex dest)</a>
<a class="sourceLine" id="cb33-19" title="19">{</a>
<a class="sourceLine" id="cb33-20" title="20">    visited = calloc (g-&gt;nV, <span class="kw">sizeof</span> (<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb33-21" title="21">    <span class="dt">int</span> res = HamiltonR (g, src, dest, g-&gt;nV - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb33-22" title="22">    free (visited);</a>
<a class="sourceLine" id="cb33-23" title="23">    <span class="cf">return</span> res;</a>
<a class="sourceLine" id="cb33-24" title="24">}</a></code></pre></div>
</div>
<h2 id="directed-graphs">Directed Graphs</h2>
<div class="panel panel-default">
<div id="digraph-commentary" class="panel-heading">
<strong> Interface and Representation </strong>
</div>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb34-1" title="1"><span class="co">// Same interface as for simple graphs</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="co">// Representation changes:</span></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="co">// - essentially the same data structures</span></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="co">// - if using adjacency matrix, no longer symmetric</span></a>
<a class="sourceLine" id="cb34-5" title="5"><span class="co">// - if using adjacency lists, no longer store (v,w) and (w,v)</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="digraph-rtc" class="panel-heading">
<strong> Reachability, Transitive Closure </strong>
</div>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="co">// to your chosen graph implementation, add:</span></a>
<a class="sourceLine" id="cb35-2" title="2"></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="dt">int</span> **tc; <span class="co">// VxV matrix indicating reachability</span></a>
<a class="sourceLine" id="cb35-4" title="4"></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="co">// is there some path from src to dest</span></a>
<a class="sourceLine" id="cb35-6" title="6"><span class="dt">int</span> reachable (Graph g, Vertex src, Vertex dest)</a>
<a class="sourceLine" id="cb35-7" title="7">{</a>
<a class="sourceLine" id="cb35-8" title="8">    <span class="cf">if</span> (g-&gt;tc == NULL)</a>
<a class="sourceLine" id="cb35-9" title="9">        makeClosure (g);</a>
<a class="sourceLine" id="cb35-10" title="10">    <span class="cf">return</span> g-&gt;tc[src][dest];</a>
<a class="sourceLine" id="cb35-11" title="11">}</a>
<a class="sourceLine" id="cb35-12" title="12"></a>
<a class="sourceLine" id="cb35-13" title="13"><span class="co">// build transitive closure matrix</span></a>
<a class="sourceLine" id="cb35-14" title="14"><span class="dt">void</span> makeClosure (Graph g)</a>
<a class="sourceLine" id="cb35-15" title="15">{</a>
<a class="sourceLine" id="cb35-16" title="16">    <span class="dt">int</span> i, s, t, V = g-&gt;nV;</a>
<a class="sourceLine" id="cb35-17" title="17">    tc = makeMatrix (V, V, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb35-18" title="18">    <span class="cf">for</span> (s = <span class="dv">0</span>; s &lt; V; s++) {</a>
<a class="sourceLine" id="cb35-19" title="19">        <span class="cf">for</span> (t = <span class="dv">0</span>; t &lt; V; t++)</a>
<a class="sourceLine" id="cb35-20" title="20">            tc[s][t] = g-&gt;edges[s][t];</a>
<a class="sourceLine" id="cb35-21" title="21">    }</a>
<a class="sourceLine" id="cb35-22" title="22">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; V; i++) {</a>
<a class="sourceLine" id="cb35-23" title="23">        <span class="cf">for</span> (s = <span class="dv">0</span>; s &lt; V; s++) {</a>
<a class="sourceLine" id="cb35-24" title="24">            <span class="cf">if</span> (tc[s][i] == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb35-25" title="25">                <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb35-26" title="26">            <span class="cf">for</span> (t = <span class="dv">0</span>; t &lt; V; t++)</a>
<a class="sourceLine" id="cb35-27" title="27">                <span class="cf">if</span> (tc[i][t] == <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb35-28" title="28">                    tc[s][t] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb35-29" title="29">        }</a>
<a class="sourceLine" id="cb35-30" title="30">    }</a>
<a class="sourceLine" id="cb35-31" title="31">    g-&gt;tc = tc;</a>
<a class="sourceLine" id="cb35-32" title="32">}</a>
<a class="sourceLine" id="cb35-33" title="33"></a>
<a class="sourceLine" id="cb35-34" title="34"><span class="co">// build an empty VxV matrix</span></a>
<a class="sourceLine" id="cb35-35" title="35"><span class="dt">int</span> **makeMatrix (<span class="dt">int</span> nrows, <span class="dt">int</span> ncols, <span class="dt">int</span> init)</a>
<a class="sourceLine" id="cb35-36" title="36">{</a>
<a class="sourceLine" id="cb35-37" title="37">    <span class="dt">int</span> i, j;</a>
<a class="sourceLine" id="cb35-38" title="38">    <span class="dt">int</span> **m = malloc (nrows * <span class="kw">sizeof</span> (<span class="dt">int</span> *));</a>
<a class="sourceLine" id="cb35-39" title="39">    assert (m != NULL);</a>
<a class="sourceLine" id="cb35-40" title="40">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; nrows; i++) {</a>
<a class="sourceLine" id="cb35-41" title="41">        m[i] = malloc (ncols * <span class="kw">sizeof</span> (<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb35-42" title="42">        assert (m[i] != NULL);</a>
<a class="sourceLine" id="cb35-43" title="43">        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; ncols; j++)</a>
<a class="sourceLine" id="cb35-44" title="44">            m[i][j] = init;</a>
<a class="sourceLine" id="cb35-45" title="45">    }</a>
<a class="sourceLine" id="cb35-46" title="46">    <span class="cf">return</span> m;</a>
<a class="sourceLine" id="cb35-47" title="47">}</a></code></pre></div>
</div>
<h2 id="weighted-graphs">Weighted Graphs</h2>
<div class="panel panel-default">
<div id="wgraph" class="panel-heading">
<strong> Interface and Representation </strong>
</div>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="co">// wgraph.h</span></a>
<a class="sourceLine" id="cb36-2" title="2"></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co">// visible data structures for Graphs</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="kw">typedef</span> <span class="kw">struct</span> GraphRep *Graph;</a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co">// vertices denoted by integers 0..N-1</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="kw">typedef</span> <span class="dt">int</span> Vertex;</a>
<a class="sourceLine" id="cb36-7" title="7"><span class="co">// edges are end-points + weight</span></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="kw">typedef</span> <span class="kw">struct</span> { Vertex src; Vertex dest; <span class="dt">float</span> weight; } Edge;</a>
<a class="sourceLine" id="cb36-9" title="9"><span class="co">// auxiliary operations on graphs</span></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="dt">int</span> validV(Graph,Vertex); <span class="co">// validity check</span></a>
<a class="sourceLine" id="cb36-11" title="11">Edge mkEdge(Graph, Vertex, Vertex, <span class="dt">float</span>); <span class="co">// edge creation</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="dt">int</span> neighbours(Graph, Vertex, Vertex); <span class="co">// edge existence</span></a>
<a class="sourceLine" id="cb36-13" title="13"><span class="dt">float</span> compareE(Edge e1, Edge e2); <span class="co">// compare edge weights</span></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="co">// core operations on graphs</span></a>
<a class="sourceLine" id="cb36-15" title="15"><span class="co">// make new graph with nV vertices</span></a>
<a class="sourceLine" id="cb36-16" title="16">Graph newGraph(<span class="dt">int</span> nV);</a>
<a class="sourceLine" id="cb36-17" title="17"><span class="co">// free memory allocated to graph</span></a>
<a class="sourceLine" id="cb36-18" title="18"><span class="dt">void</span> dropGraph(Graph);</a>
<a class="sourceLine" id="cb36-19" title="19"><span class="co">// show "printable" representation of graph</span></a>
<a class="sourceLine" id="cb36-20" title="20"><span class="dt">void</span> showGraph(Graph);</a>
<a class="sourceLine" id="cb36-21" title="21"><span class="co">// add new edge to a graph</span></a>
<a class="sourceLine" id="cb36-22" title="22"><span class="dt">void</span> insertE(Graph, Edge);</a>
<a class="sourceLine" id="cb36-23" title="23"><span class="co">// remove an edge from a graph</span></a>
<a class="sourceLine" id="cb36-24" title="24"><span class="dt">void</span> removeE(Graph, Edge);</a>
<a class="sourceLine" id="cb36-25" title="25"><span class="co">// returns #vertices &amp; array of edges</span></a>
<a class="sourceLine" id="cb36-26" title="26"><span class="dt">int</span> edges(Graph, Edge *, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb36-27" title="27"></a>
<a class="sourceLine" id="cb36-28" title="28"><span class="kw">typedef</span> Graph MSTree; <span class="co">// an MST is a specialised Graph</span></a>
<a class="sourceLine" id="cb36-29" title="29"></a>
<a class="sourceLine" id="cb36-30" title="30"><span class="co">// EOF</span></a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="wgraph-aux" class="panel-heading">
<strong> Auxiliary Operations </strong>
</div>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="pp">#include </span><span class="im">"wgraph.h"</span></a>
<a class="sourceLine" id="cb37-2" title="2"></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="co">// is a vertex valid in a given Graph?</span></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="dt">int</span> validV (Graph g, Vertex v)</a>
<a class="sourceLine" id="cb37-5" title="5">{</a>
<a class="sourceLine" id="cb37-6" title="6">    <span class="cf">return</span> (g != NULL &amp;&amp; v &gt;= <span class="dv">0</span> &amp;&amp; v &lt; g-&gt;nV);</a>
<a class="sourceLine" id="cb37-7" title="7">}</a>
<a class="sourceLine" id="cb37-8" title="8"></a>
<a class="sourceLine" id="cb37-9" title="9"><span class="co">// make an Edge value</span></a>
<a class="sourceLine" id="cb37-10" title="10">Edge mkEdge (Graph g, Vertex v, Vertex w, <span class="dt">float</span> weight)</a>
<a class="sourceLine" id="cb37-11" title="11">{</a>
<a class="sourceLine" id="cb37-12" title="12">    assert (validV (g, v) &amp;&amp; validV (g, w));</a>
<a class="sourceLine" id="cb37-13" title="13">    <span class="cf">return</span> (Edge) { .src = v, .dest = w, .weight = weight };</a>
<a class="sourceLine" id="cb37-14" title="14">}</a>
<a class="sourceLine" id="cb37-15" title="15"><span class="co">// compare Edge weights</span></a>
<a class="sourceLine" id="cb37-16" title="16"><span class="dt">float</span></a>
<a class="sourceLine" id="cb37-17" title="17">compareE (Edge e1, Edge e2)</a>
<a class="sourceLine" id="cb37-18" title="18">{</a>
<a class="sourceLine" id="cb37-19" title="19">    <span class="cf">return</span> e1.weight - e2.weight;</a>
<a class="sourceLine" id="cb37-20" title="20">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="wgraph-adjmatrix" class="panel-heading">
<strong> Adjacency Matrix Implementation </strong>
</div>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb38-1" title="1"><span class="co">// wgraph_adjmatrix.c</span></a>
<a class="sourceLine" id="cb38-2" title="2"></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="co">// since 0 is a valid weight, can't use it for "no edge"</span></a>
<a class="sourceLine" id="cb38-4" title="4"><span class="co">// need a distinguished value to indicate "no edge"</span></a>
<a class="sourceLine" id="cb38-5" title="5"><span class="pp">#define NO_EDGE FLT_MAX  </span><span class="co">// imaginary distinguished float value</span></a>
<a class="sourceLine" id="cb38-6" title="6"><span class="kw">typedef</span> <span class="kw">struct</span> GraphRep {</a>
<a class="sourceLine" id="cb38-7" title="7">    <span class="dt">int</span>    nV;    <span class="co">// #vertices</span></a>
<a class="sourceLine" id="cb38-8" title="8">    <span class="dt">int</span>    nE;    <span class="co">// #edges</span></a>
<a class="sourceLine" id="cb38-9" title="9">    <span class="dt">float</span> **edges; <span class="co">// matrix of weights</span></a>
<a class="sourceLine" id="cb38-10" title="10">} GraphRep;</a>
<a class="sourceLine" id="cb38-11" title="11"></a>
<a class="sourceLine" id="cb38-12" title="12"><span class="co">// check whether two vertices are connected</span></a>
<a class="sourceLine" id="cb38-13" title="13"><span class="dt">int</span> neighbours (Graph g, Vertex v, Vertex w)</a>
<a class="sourceLine" id="cb38-14" title="14">{</a>
<a class="sourceLine" id="cb38-15" title="15">    assert (validV (g, v) &amp;&amp; validV (g, w));</a>
<a class="sourceLine" id="cb38-16" title="16">    <span class="cf">return</span> (g-&gt;edges[v][w] != NO_EDGE);</a>
<a class="sourceLine" id="cb38-17" title="17">}</a>
<a class="sourceLine" id="cb38-18" title="18"></a>
<a class="sourceLine" id="cb38-19" title="19"><span class="co">// make new graph with nV vertices</span></a>
<a class="sourceLine" id="cb38-20" title="20">Graph newGraph (<span class="dt">int</span> nV)</a>
<a class="sourceLine" id="cb38-21" title="21">{</a>
<a class="sourceLine" id="cb38-22" title="22">    assert (nV &gt;= <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb38-23" title="23">    <span class="dt">int</span> i, j;</a>
<a class="sourceLine" id="cb38-24" title="24">    <span class="dt">float</span> **e = malloc (nV * <span class="kw">sizeof</span> (<span class="dt">float</span> *));</a>
<a class="sourceLine" id="cb38-25" title="25">    assert (e != NULL);</a>
<a class="sourceLine" id="cb38-26" title="26">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; nV; i++) {</a>
<a class="sourceLine" id="cb38-27" title="27">        e[i] = malloc (nV * <span class="kw">sizeof</span> (<span class="dt">float</span>));</a>
<a class="sourceLine" id="cb38-28" title="28">        assert (e[i] != NULL);</a>
<a class="sourceLine" id="cb38-29" title="29">        <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; nV; j++)</a>
<a class="sourceLine" id="cb38-30" title="30">            e[i][j] = NO_EDGE;</a>
<a class="sourceLine" id="cb38-31" title="31">    }</a>
<a class="sourceLine" id="cb38-32" title="32">    Graph g = malloc (<span class="kw">sizeof</span> (GraphRep));</a>
<a class="sourceLine" id="cb38-33" title="33">    assert (g != NULL);</a>
<a class="sourceLine" id="cb38-34" title="34">    g-&gt;nV = nV;</a>
<a class="sourceLine" id="cb38-35" title="35">    g-&gt;nE = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb38-36" title="36">    g-&gt;edges = e;</a>
<a class="sourceLine" id="cb38-37" title="37">    <span class="cf">return</span> g;</a>
<a class="sourceLine" id="cb38-38" title="38">}</a>
<a class="sourceLine" id="cb38-39" title="39"></a>
<a class="sourceLine" id="cb38-40" title="40"><span class="co">// free memory allocated to graph</span></a>
<a class="sourceLine" id="cb38-41" title="41"><span class="dt">void</span> dropGraph (Graph g)</a>
<a class="sourceLine" id="cb38-42" title="42">{</a>
<a class="sourceLine" id="cb38-43" title="43">    assert (g != NULL);</a>
<a class="sourceLine" id="cb38-44" title="44">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb38-45" title="45">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++)</a>
<a class="sourceLine" id="cb38-46" title="46">        free (g-&gt;edges[i]);</a>
<a class="sourceLine" id="cb38-47" title="47">    free (g-&gt;edges);</a>
<a class="sourceLine" id="cb38-48" title="48">    free (g);</a>
<a class="sourceLine" id="cb38-49" title="49">}</a>
<a class="sourceLine" id="cb38-50" title="50"></a>
<a class="sourceLine" id="cb38-51" title="51"><span class="co">// show "printable" representation of graph</span></a>
<a class="sourceLine" id="cb38-52" title="52"><span class="dt">void</span> showGraph (Graph g)</a>
<a class="sourceLine" id="cb38-53" title="53">{</a>
<a class="sourceLine" id="cb38-54" title="54">    assert (g != NULL);</a>
<a class="sourceLine" id="cb38-55" title="55">    printf (<span class="st">"V=%d, E=%d</span><span class="sc">\n</span><span class="st">"</span>, g-&gt;nV, g-&gt;nE);</a>
<a class="sourceLine" id="cb38-56" title="56">    <span class="dt">int</span> i, j;</a>
<a class="sourceLine" id="cb38-57" title="57">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++) {</a>
<a class="sourceLine" id="cb38-58" title="58">        <span class="dt">int</span> nshown = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb38-59" title="59">        <span class="cf">for</span> (j = i + <span class="dv">1</span>; j &lt; g-&gt;nV; j++) {</a>
<a class="sourceLine" id="cb38-60" title="60">            <span class="dt">float</span> wt = g-&gt;edges[i][j];</a>
<a class="sourceLine" id="cb38-61" title="61">            <span class="cf">if</span> (wt != NO_EDGE) {</a>
<a class="sourceLine" id="cb38-62" title="62">                printf (<span class="st">"%d-%0.1f-%d "</span>, i, wt, j);</a>
<a class="sourceLine" id="cb38-63" title="63">                nshown++;</a>
<a class="sourceLine" id="cb38-64" title="64">            }</a>
<a class="sourceLine" id="cb38-65" title="65">        }</a>
<a class="sourceLine" id="cb38-66" title="66">        <span class="cf">if</span> (nshown &gt; <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb38-67" title="67">            printf (<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>);</a>
<a class="sourceLine" id="cb38-68" title="68">    }</a>
<a class="sourceLine" id="cb38-69" title="69">}</a>
<a class="sourceLine" id="cb38-70" title="70"></a>
<a class="sourceLine" id="cb38-71" title="71"><span class="co">// add new edge to a graph</span></a>
<a class="sourceLine" id="cb38-72" title="72"><span class="dt">void</span> insertE (Graph g, Edge e)</a>
<a class="sourceLine" id="cb38-73" title="73">{</a>
<a class="sourceLine" id="cb38-74" title="74">    assert (g != NULL);</a>
<a class="sourceLine" id="cb38-75" title="75">    Vertex v = e.src, w = e.dest;</a>
<a class="sourceLine" id="cb38-76" title="76">    assert (validV (g, v) &amp;&amp; validV (g, w));</a>
<a class="sourceLine" id="cb38-77" title="77">    <span class="cf">if</span> (g-&gt;edges[v][w] == NO_EDGE)</a>
<a class="sourceLine" id="cb38-78" title="78">        g-&gt;nE++;</a>
<a class="sourceLine" id="cb38-79" title="79">    g-&gt;edges[v][w] = e.weight;</a>
<a class="sourceLine" id="cb38-80" title="80">}</a>
<a class="sourceLine" id="cb38-81" title="81"></a>
<a class="sourceLine" id="cb38-82" title="82"><span class="co">// remove an edge from a graph</span></a>
<a class="sourceLine" id="cb38-83" title="83"><span class="dt">void</span> removeE (Graph g, Edge e)</a>
<a class="sourceLine" id="cb38-84" title="84">{</a>
<a class="sourceLine" id="cb38-85" title="85">    assert (g != NULL);</a>
<a class="sourceLine" id="cb38-86" title="86">    Vertex v = e.src, w = e.dest;</a>
<a class="sourceLine" id="cb38-87" title="87">    assert (validV (g, v) &amp;&amp; validV (g, w));</a>
<a class="sourceLine" id="cb38-88" title="88">    <span class="cf">if</span> (g-&gt;edges[v][w] == NO_EDGE)</a>
<a class="sourceLine" id="cb38-89" title="89">        <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb38-90" title="90">    g-&gt;edges[v][w] = NO_EDGE;</a>
<a class="sourceLine" id="cb38-91" title="91">    g-&gt;edges[w][v] = NO_EDGE;</a>
<a class="sourceLine" id="cb38-92" title="92">    g-&gt;nE--;</a>
<a class="sourceLine" id="cb38-93" title="93">}</a>
<a class="sourceLine" id="cb38-94" title="94"></a>
<a class="sourceLine" id="cb38-95" title="95"><span class="co">// returns #vertices &amp; array of edges</span></a>
<a class="sourceLine" id="cb38-96" title="96"><span class="dt">int</span> edges (Graph g, Edge *es, <span class="dt">int</span> nE)</a>
<a class="sourceLine" id="cb38-97" title="97">{</a>
<a class="sourceLine" id="cb38-98" title="98">    assert (g != NULL &amp;&amp; es != NULL);</a>
<a class="sourceLine" id="cb38-99" title="99">    assert (nE &gt;= g-&gt;nE);</a>
<a class="sourceLine" id="cb38-100" title="100">    <span class="dt">int</span> i, j, n = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb38-101" title="101">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++) {</a>
<a class="sourceLine" id="cb38-102" title="102">        <span class="cf">for</span> (j = i + <span class="dv">1</span>; j &lt; g-&gt;nV; j++) {</a>
<a class="sourceLine" id="cb38-103" title="103">            <span class="cf">if</span> (g-&gt;edges[i][j] != NO_EDGE) {</a>
<a class="sourceLine" id="cb38-104" title="104">                assert (n &lt; nE);</a>
<a class="sourceLine" id="cb38-105" title="105">                es[n++] = mkEdge (g, i, j, g-&gt;edges[i][j]);</a>
<a class="sourceLine" id="cb38-106" title="106">            }</a>
<a class="sourceLine" id="cb38-107" title="107">        }</a>
<a class="sourceLine" id="cb38-108" title="108">    }</a>
<a class="sourceLine" id="cb38-109" title="109">    <span class="cf">return</span> n;</a>
<a class="sourceLine" id="cb38-110" title="110">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="wgraph-mst-kruskal" class="panel-heading">
<strong> Minimum Spanning Tree (Kruskal) </strong>
</div>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb39-1" title="1"><span class="co">// wgraph_mst_kruskal.c</span></a>
<a class="sourceLine" id="cb39-2" title="2"></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="co">// assumes existence of list-of-edges ADT</span></a>
<a class="sourceLine" id="cb39-4" title="4">MSTree kruskalFindMST (Graph g)</a>
<a class="sourceLine" id="cb39-5" title="5">{</a>
<a class="sourceLine" id="cb39-6" title="6">    Graph mst = newGraph (); <span class="co">// MST initially empty</span></a>
<a class="sourceLine" id="cb39-7" title="7">    EdgeList eList;          <span class="co">// sorted list of edges</span></a>
<a class="sourceLine" id="cb39-8" title="8">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb39-9" title="9">    Edge e;</a>
<a class="sourceLine" id="cb39-10" title="10">    <span class="dt">int</span> eSize = <span class="kw">sizeof</span> (Edge);</a>
<a class="sourceLine" id="cb39-11" title="11">    edges (eList, g-&gt;nE, g);</a>
<a class="sourceLine" id="cb39-12" title="12">    eList = qsort (sorted, g-&gt;nE, eSize, compareE);</a>
<a class="sourceLine" id="cb39-13" title="13">    <span class="cf">for</span> (i = <span class="dv">0</span>; mst-&gt;nE &lt; g-&gt;nV - <span class="dv">1</span>; i++) {</a>
<a class="sourceLine" id="cb39-14" title="14">        e = eList[i];</a>
<a class="sourceLine" id="cb39-15" title="15">        insertE (mst, e);</a>
<a class="sourceLine" id="cb39-16" title="16">        <span class="cf">if</span> (hasCycle (mst))</a>
<a class="sourceLine" id="cb39-17" title="17">            removeE (mst, e);</a>
<a class="sourceLine" id="cb39-18" title="18">    }</a>
<a class="sourceLine" id="cb39-19" title="19">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="wgraph-mst-prim" class="panel-heading">
<strong> Minimum Spanning Tree (Prim-Jarnik-Dijkstra) </strong>
</div>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb40-1" title="1"><span class="co">// wgraph_mst_prim.c</span></a>
<a class="sourceLine" id="cb40-2" title="2"></a>
<a class="sourceLine" id="cb40-3" title="3"><span class="co">// assumes existence of set-of-edges ADT</span></a>
<a class="sourceLine" id="cb40-4" title="4"><span class="co">// assumes existence of set-of-vertices ADT</span></a>
<a class="sourceLine" id="cb40-5" title="5">MSTree primFindMST(Graph g)</a>
<a class="sourceLine" id="cb40-6" title="6">{</a>
<a class="sourceLine" id="cb40-7" title="7">    EdgeSet mst = {}; <span class="co">//MST initially empty</span></a>
<a class="sourceLine" id="cb40-8" title="8">    VertexSet vSet = {<span class="dv">0</span>}; <span class="co">// start vertex</span></a>
<a class="sourceLine" id="cb40-9" title="9">    EdgeSet fringe = {}; <span class="co">//edges at "fringe"</span></a>
<a class="sourceLine" id="cb40-10" title="10">    Vertex curr, s, t;  Edge e;  <span class="dt">float</span> w;</a>
<a class="sourceLine" id="cb40-11" title="11">    fringe = edgesAt(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb40-12" title="12">    <span class="cf">while</span> (card(vSet) &lt; g-&gt;nV) {</a>
<a class="sourceLine" id="cb40-13" title="13">        find e in fringe with minimum cost</a>
<a class="sourceLine" id="cb40-14" title="14">        fringe = exclude(fringe, e)</a>
<a class="sourceLine" id="cb40-15" title="15">        (s,curr,w) = e</a>
<a class="sourceLine" id="cb40-16" title="16">        vSet = VSInclude(vSet, curr)</a>
<a class="sourceLine" id="cb40-17" title="17">        mst = ESInclude(mst, e)</a>
<a class="sourceLine" id="cb40-18" title="18">        foreach (e in edgesAt(curr)) {</a>
<a class="sourceLine" id="cb40-19" title="19">            (s,t,w) = e  <span class="co">// s == curr</span></a>
<a class="sourceLine" id="cb40-20" title="20">            <span class="cf">if</span> (!isElem(t,vSet))</a>
<a class="sourceLine" id="cb40-21" title="21">                fringe = ESInclude(fringe,e)</a>
<a class="sourceLine" id="cb40-22" title="22">        }</a>
<a class="sourceLine" id="cb40-23" title="23">    }</a>
<a class="sourceLine" id="cb40-24" title="24">}</a></code></pre></div>
</div>
<div class="panel panel-default">
<div id="wgraph-sssp-dijkstra" class="panel-heading">
<strong> Single-Source-Shortest-Path (Dijkstra) </strong>
</div>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb41-1" title="1"><span class="co">// wgraph_sssp_dijkstra.c</span></a>
<a class="sourceLine" id="cb41-2" title="2"><span class="pp">#include </span><span class="im">"pqueue.h"</span></a>
<a class="sourceLine" id="cb41-3" title="3"></a>
<a class="sourceLine" id="cb41-4" title="4"><span class="dt">float</span> *dist; <span class="co">// dist[d] = distance of shortest path from s..d</span></a>
<a class="sourceLine" id="cb41-5" title="5">Vertex *pred; <span class="co">// pred[v] = predecessor of v in shortest path</span></a>
<a class="sourceLine" id="cb41-6" title="6"></a>
<a class="sourceLine" id="cb41-7" title="7"><span class="co">// assumes existence of set-of-vertices ADT</span></a>
<a class="sourceLine" id="cb41-8" title="8"><span class="co">// assumes existence of priority queue ADT</span></a>
<a class="sourceLine" id="cb41-9" title="9"><span class="co">// abstract algorithm only ...</span></a>
<a class="sourceLine" id="cb41-10" title="10">MSTree shortestPath (Graph g, Vertex s)</a>
<a class="sourceLine" id="cb41-11" title="11">{</a>
<a class="sourceLine" id="cb41-12" title="12">    VertexSet vSet = {};        <span class="co">// visited vertices</span></a>
<a class="sourceLine" id="cb41-13" title="13">    PQueue todo = newPQueue (); <span class="co">// edges to be considered</span></a>
<a class="sourceLine" id="cb41-14" title="14">    <span class="dt">float</span> *dist = malloc (g-&gt;nV * <span class="kw">sizeof</span> (<span class="dt">float</span>));</a>
<a class="sourceLine" id="cb41-15" title="15">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++) dist[i] = MAXFLOAT;</a>
<a class="sourceLine" id="cb41-16" title="16">    dist[s] = <span class="fl">0.0</span>;</a>
<a class="sourceLine" id="cb41-17" title="17">    Vertex *pred = malloc (g-&gt;nV * <span class="kw">sizeof</span> (Vertex));</a>
<a class="sourceLine" id="cb41-18" title="18">    <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; g-&gt;nV; i++) pred[i] = <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb41-19" title="19">    Vertex v, w, s, t;</a>
<a class="sourceLine" id="cb41-20" title="20">    Edge e;</a>
<a class="sourceLine" id="cb41-21" title="21">    <span class="dt">float</span> wt;</a>
<a class="sourceLine" id="cb41-22" title="22">    PQueueJoin (todo, s, dist[s]);</a>
<a class="sourceLine" id="cb41-23" title="23">    <span class="cf">while</span> (!PQueueIsEmpty (todo)) {</a>
<a class="sourceLine" id="cb41-24" title="24">        v = PQueueLeave (todo);</a>
<a class="sourceLine" id="cb41-25" title="25">        <span class="cf">if</span> (isElem (vSet, v)) <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb41-26" title="26">        vSet = VSInclude (vSet, v);</a>
<a class="sourceLine" id="cb41-27" title="27">        foreach (e = (v, w, wt) in edgesAt (v)) {</a>
<a class="sourceLine" id="cb41-28" title="28">            <span class="cf">if</span> (dist[v] + wt &lt; dist[w]) {</a>
<a class="sourceLine" id="cb41-29" title="29">                dist[w] = dist[v] + wt;</a>
<a class="sourceLine" id="cb41-30" title="30">                pred[w] = v;</a>
<a class="sourceLine" id="cb41-31" title="31">                PQueueJoin (todo, w, dist[w]);</a>
<a class="sourceLine" id="cb41-32" title="32">            }</a>
<a class="sourceLine" id="cb41-33" title="33">        }</a>
<a class="sourceLine" id="cb41-34" title="34">    }</a>
<a class="sourceLine" id="cb41-35" title="35">}</a></code></pre></div>
</div>


</body></html>