<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  <title>Tutorial Solutions — COMP2521 19T0: Data Structures and Algorithms</title>

  <link rel="stylesheet" href="/~cs2521/19T0/assets/main.css" />
  <link rel="canonical" href="https://www.cse.unsw.edu.au/~cs2521/19T0/week07/20_tutorial_solutions/" />
</head>
<body class="d-flex flex-column" style="min-height: 100vh;">

  <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary no-print" id="header-navbar">
    <button class="navbar-toggler navbar-toggler-right"
            type="button" data-toggle="collapse" data-target="#navmenu"
            aria-controls="navmenu" aria-label="Toggle navigation" aria-expanded="false">
      <span class="navbar-toggler-icon"></span>
    </button>

  <div class="container">
    <a class="navbar-brand" href="/~cs2521/19T0/">
      COMP2521 19T0
    </a>

    <div class="collapse navbar-collapse" id="navmenu">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/webcms/">WebCMS3</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/outline/">Outline</a></li>
        <li class="navbar-text px-4">|</li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/assignments/textbuffer/">A1</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/assignments/dracula/">A2</a></li>
        <li class="navbar-text px-4">|</li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/week01/">1</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/week02/">2</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/week03/">3</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/week04/">4</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/week05/">5</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/week06/">6</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/week07/">7</a></li>
        <li class="nav-item"><a class="nav-link" href="/~cs2521/19T0/week08/">8</a></li>

      </ul>
    </div>
  </div>
</nav>

<div class="container" id="breadcrumb">
  
  <ol class="breadcrumb no-print" style="margin: 0">
    
    
      
      
      
      <li class="breadcrumb-item">
        <a href="/~cs2521/19T0/">Home</a>
      </li>
      
    
      
      
      
      <li class="breadcrumb-item">
        <a href="/~cs2521/19T0/week07/">Week 7</a>
      </li>
      
    
      
      
      
      <li class="breadcrumb-item">
        <a href="/~cs2521/19T0/week07/20_tutorial_solutions/">Tutorial Solutions</a>
      </li>
      
    
  </ol>
  
</div>


  <main class="container" aria-label="Content" style="flex: 1;">
    <main style="max-width: 88ex; margin: 0 auto;">

<header class="text-center">
  <h1 class="display-4">Tutorial Solutions</h1>
</header>





<!-- =============================================================== -->
<h3 id="see-it-say-it-sorted">See it, Say it, Sorted</h3>

<p>Break into three groups.
Each group should prepare
a short demonstration of
a sorting algorithm:
shell sort,
top-down merge sort,
heap sort.</p>

<p>Try to demonstrate how the algorithms work
and what their properties are.</p>

<h4 id="shell-sort">Shell Sort</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sort_shell</span> <span class="p">(</span><span class="n">Item</span> <span class="n">items</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">9</span><span class="p">)</span>
		<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="cm">/* h */</span><span class="p">;</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Item</span> <span class="n">item</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="n">items</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">h</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">items</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">h</span><span class="p">];</span>
				<span class="n">j</span> <span class="o">-=</span> <span class="n">h</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">items</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="merge-sort">Merge Sort</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sort_merge</span> <span class="p">(</span><span class="n">Item</span> <span class="n">items</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">sort_merge</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
	<span class="n">sort_merge</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
	<span class="n">merge</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">merge</span> <span class="p">(</span><span class="n">Item</span> <span class="n">items</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Item</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">calloc</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">Item</span><span class="p">));</span>
	<span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">)</span>
		<span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span>
			<span class="o">=</span> <span class="n">less</span> <span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="o">?</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span>
			<span class="o">:</span> <span class="n">items</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">)</span>  <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">hi</span><span class="p">;</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]);</span>

	<span class="n">free</span> <span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="heap-sort">Heap Sort</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sort_heap</span> <span class="p">(</span><span class="n">Item</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">N</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">Item</span> <span class="o">*</span><span class="n">pq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">lo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">--</span><span class="p">)</span>
		<span class="n">heap_fixdown</span> <span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swap_idx</span> <span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
		<span class="n">heap_fixdown</span> <span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">--</span><span class="n">N</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// move value at a[k] to correct position</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">heap_fixdown</span> <span class="p">(</span><span class="n">Item</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">N</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span> <span class="c1">// choose greater child</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">item_cmp</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">item_cmp</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
		<span class="n">swap_idx</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<aside class="answer">
  <blockquote>
    <p>A summary of the various properties for these implementations:</p>

    <table class="table table-sm">
<thead>
<tr><th>algorithm</th>
    <th>complexity</th>
    <th>adaptive?</th>
    <th>stable?</th>
    <th>in-place?</th></tr>
</thead>
<tbody>
<tr><th scope="row">Shell sort</th>
    <td>$$O(x)$$</td>
    <td>yes</td>
    <td>no</td>
    <td>yes</td></tr>
<tr><th scope="row">merge sort</th>
    <td>$$O(n\log n)$$</td>
    <td>no</td>
    <td>yes</td>
    <td>no</td></tr>
<tr><th scope="row">heap sort</th>
    <td>$$O(n\log n)$$</td>
    <td>no</td>
    <td>no</td>
    <td>yes</td></tr>
</tbody>
</table>
  </blockquote>
</aside>

<hr />

<!-- =============================================================== -->
<h3 id="quickly-now">Quickly, now!</h3>

<p>One improvement to the quicksort algorithm that we discussed
was the use of <em>median-of-three partitioning</em>.
In this version of quicksort,
three items in the array are sampled,
and the median of these three values is used
to partition the array.
Without looking at the C code given in lectures,
complete the following program
by replacing the comments
with the relevant C program statements.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Quick sort with median-of-three partitioning.</span>
<span class="kt">void</span> <span class="nf">sort_quick_m3</span> <span class="p">(</span><span class="n">Item</span> <span class="n">items</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qs_median3</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">qs_partition</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">qs_partition</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sort_quick_m3</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sort_quick_m3</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">qs_median3</span> <span class="p">(</span><span class="n">Item</span> <span class="n">items</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Swap median (value mid-way between `lo' and `hi') with items[hi-1]</span>
	<span class="c1">// Compare items[lo], items[hi-1] and items[hi]</span>
	<span class="c1">// Rearrange values:</span>
	<span class="c1">//   lowest value to be stored in items[lo]</span>
	<span class="c1">//   highest value to be stored in items[hi]</span>
	<span class="c1">//   median value to be stored in items[hi-1]</span>
<span class="p">}</span>
</code></pre></div></div>

<aside class="answer">
  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">qs_median3</span> <span class="p">(</span><span class="n">Item</span> <span class="n">items</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">lo</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Swap median value with items[hi-1]</span>
	<span class="n">swap_idx</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="p">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="c1">// Compare items[lo], items[hi-1] and items[hi]</span>
	<span class="c1">// Rearrange values:</span>
	<span class="c1">//   lowest value to be stored in items[lo]</span>
	<span class="c1">//   highest value to be stored in items[hi]</span>
	<span class="c1">//   median value to be stored in items[hi-1]</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">less</span> <span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="n">lo</span><span class="p">]))</span>
		<span class="n">swap_idx</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">less</span> <span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">hi</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="n">lo</span><span class="p">]))</span>
    	<span class="n">swap_idx</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">less</span> <span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">hi</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="n">hi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
		<span class="n">swap_idx</span> <span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">lo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>  </div>
</aside>

<p>Trace the calls of <code class="highlighter-rouge">qs_median3</code> and <code class="highlighter-rouge">qs_partition</code>
on the sequence <script type="math/tex">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</script>.</p>

<p>Compare it to standard quicksort.</p>

<aside class="answer">

  <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--&gt; quicksort(array, 0, 9);

    array: [(1  2  3  4  5  6  7  8  9  10)]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ---

    At the start of the function:
    array: [(1  2  3  4  5  6  7  8  9  10)]

    --&gt; median3(array, 0, 9);

        1. Swapping array[mid] and array[right-1] unconditionally
        array: [(1  2  3  4  9  6  7  8  5  10)]
                             ^           ^
        2. Swapping array[left] and array[right-1] if needed
        array: [(1  2  3  4  9  6  7  8  5  10)]
                 ^                       ^
        3. Swapping array[left] and array[right] if needed
        array: [(1  2  3  4  9  6  7  8  5  10)]
                 ^                          ^
        4. Swapping array[right-1] and array[right] if needed
        array: [(1  2  3  4  9  6  7  8  5  10)]
                                         ^  ^
    --&gt; partition(array, 1, 8);

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                   ^^^^^^^^^^^^^^^^^^^^^^^^
        ---

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                                         ^ pivot

        Going from left to right, starting at array[1]:

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                    ^                    ^
                    L                    P
        array[1] is less than our pivot, so keep moving...

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                       ^                 ^
                       L                 P
        array[2] is less than our pivot, so keep moving...

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                          ^              ^
                          L              P
        array[3] is less than our pivot, so keep moving...

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                             ^           ^
                             L           P
        array[4] is not less than our pivot, so stop there!

        ---

        Going from right to left, starting at array[7]:

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                                      ^  ^
                                      R  P
        array[7] is greater than our pivot, so keep moving...

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                                   ^     ^
                                   R     P
        array[6] is greater than our pivot, so keep moving...

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                                ^        ^
                                R        P
        array[5] is greater than our pivot, so keep moving...

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                             ^           ^
                             R           P
        array[4] is greater than our pivot, so keep moving...

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                          ^              ^
                          R              P
        array[3] is not greater than our pivot, so stop there!

        ---

        array: [ 1 (2  3  4  9  6  7  8  5) 10 ]
                          ^  ^
                          R  L
        left &gt; right, so we're done!

        ---

        Swapping the pivot into the correct place...
        array: [ 1 (2  3  4  5  6  7  8  9) 10 ]
                             ^           ^
                             L           P

        We now know for sure that the pivot is in the correct place!
        array: [ 1 (2  3  4  5  6  7  8  9) 10 ]
                             ^
                             P

--&gt; back in quicksort(array, 0, 9);

    Recursing...

    --&gt; quicksort(array, 0, 3);

        array: [(1  2  3  4) 5  6  7  8  9  10 ]
                ^^^^^^^^^^^^
        ---

        At the start of the function:
        array: [(1  2  3  4) 5  6  7  8  9  10 ]

        --&gt; median3(array, 0, 3);

            1. Swapping array[mid] and array[right-1] unconditionally
            array: [(1  3  2  4) 5  6  7  8  9  10 ]
                        ^  ^
            2. Swapping array[left] and array[right-1] if needed
            array: [(1  3  2  4) 5  6  7  8  9  10 ]
                     ^     ^
            3. Swapping array[left] and array[right] if needed
            array: [(1  3  2  4) 5  6  7  8  9  10 ]
                     ^        ^
            4. Swapping array[right-1] and array[right] if needed
            array: [(1  3  2  4) 5  6  7  8  9  10 ]
                           ^  ^
        --&gt; partition(array, 1, 2);

            array: [ 1 (3  2) 4  5  6  7  8  9  10 ]
                       ^^^^^^
            ---

            array: [ 1 (3  2) 4  5  6  7  8  9  10 ]
                           ^ pivot

            Going from left to right, starting at array[1]:

            array: [ 1 (3  2) 4  5  6  7  8  9  10 ]
                        ^  ^
                        L  P
            array[1] is not less than our pivot, so stop there!

            ---

            Going from right to left, starting at array[1]:

            array: [ 1 (3  2) 4  5  6  7  8  9  10 ]
                        ^  ^
                        R  P
            array[1] is greater than our pivot, so keep moving...

            array: [ 1 (3  2) 4  5  6  7  8  9  10 ]
                     ^     ^
                     R     P
            array[0] is not greater than our pivot, so stop there!

            ---

            array: [ 1 (3  2) 4  5  6  7  8  9  10 ]
                     ^  ^
                     R  L
            left &gt; right, so we're done!

            ---

            Swapping the pivot into the correct place...
            array: [ 1 (2  3) 4  5  6  7  8  9  10 ]
                        ^  ^
                        L  P

            We now know for sure that the pivot is in the correct place!
            array: [ 1 (2  3) 4  5  6  7  8  9  10 ]
                        ^
                        P

    --&gt; back in quicksort(array, 0, 3);

        Recursing...

        --&gt; quicksort(array, 0, 0);

            array: [(1) 2  3  4  5  6  7  8  9  10 ]
                    ^^^
            ---

            left &gt;= right, so nothing to do here!

    --&gt; back in quicksort(array, 0, 3);

        --&gt; quicksort(array, 2, 3);

            array: [ 1  2 (3  4) 5  6  7  8  9  10 ]
                          ^^^^^^
            ---

            At the start of the function:
            array: [ 1  2 (3  4) 5  6  7  8  9  10 ]

            --&gt; median3(array, 2, 3);

                1. Swapping array[mid] and array[right-1] unconditionally
                array: [ 1  2 (3  4) 5  6  7  8  9  10 ]
                               ^
                2. Swapping array[left] and array[right-1] if needed
                array: [ 1  2 (3  4) 5  6  7  8  9  10 ]
                               ^
                3. Swapping array[left] and array[right] if needed
                array: [ 1  2 (3  4) 5  6  7  8  9  10 ]
                               ^  ^
                4. Swapping array[right-1] and array[right] if needed
                array: [ 1  2 (3  4) 5  6  7  8  9  10 ]
                               ^  ^
            --&gt; partition(array, 3, 2);

                start &gt; end, so nothing to do here!

        --&gt; back in quicksort(array, 2, 3);

            Recursing...

            --&gt; quicksort(array, 2, 2);

                array: [ 1  2 (3) 4  5  6  7  8  9  10 ]
                              ^^^
                ---

                left &gt;= right, so nothing to do here!

        --&gt; back in quicksort(array, 2, 3);

            --&gt; quicksort(array, 4, 3);

                array: [ 1  2  3  4)(5  6  7  8  9  10 ]

                ---

                left &gt;= right, so nothing to do here!

        --&gt; back in quicksort(array, 2, 3);

    --&gt; back in quicksort(array, 0, 3);

--&gt; back in quicksort(array, 0, 9);

    --&gt; quicksort(array, 5, 9);

        array: [ 1  2  3  4  5 (6  7  8  9  10)]
                               ^^^^^^^^^^^^^^^
        ---

        At the start of the function:
        array: [ 1  2  3  4  5 (6  7  8  9  10)]

        --&gt; median3(array, 5, 9);

            1. Swapping array[mid] and array[right-1] unconditionally
            array: [ 1  2  3  4  5 (6  7  9  8  10)]
                                          ^  ^
            2. Swapping array[left] and array[right-1] if needed
            array: [ 1  2  3  4  5 (6  7  9  8  10)]
                                    ^        ^
            3. Swapping array[left] and array[right] if needed
            array: [ 1  2  3  4  5 (6  7  9  8  10)]
                                    ^           ^
            4. Swapping array[right-1] and array[right] if needed
            array: [ 1  2  3  4  5 (6  7  9  8  10)]
                                             ^  ^
        --&gt; partition(array, 6, 8);

            array: [ 1  2  3  4  5  6 (7  9  8) 10 ]
                                      ^^^^^^^^^
            ---

            array: [ 1  2  3  4  5  6 (7  9  8) 10 ]
                                             ^ pivot

            Going from left to right, starting at array[6]:

            array: [ 1  2  3  4  5  6 (7  9  8) 10 ]
                                       ^     ^
                                       L     P
            array[6] is less than our pivot, so keep moving...

            array: [ 1  2  3  4  5  6 (7  9  8) 10 ]
                                          ^  ^
                                          L  P
            array[7] is not less than our pivot, so stop there!

            ---

            Going from right to left, starting at array[7]:

            array: [ 1  2  3  4  5  6 (7  9  8) 10 ]
                                          ^  ^
                                          R  P
            array[7] is greater than our pivot, so keep moving...

            array: [ 1  2  3  4  5  6 (7  9  8) 10 ]
                                       ^     ^
                                       R     P
            array[6] is not greater than our pivot, so stop there!

            ---

            array: [ 1  2  3  4  5  6 (7  9  8) 10 ]
                                       ^  ^
                                       R  L
            left &gt; right, so we're done!

            ---

            Swapping the pivot into the correct place...
            array: [ 1  2  3  4  5  6 (7  8  9) 10 ]
                                          ^  ^
                                          L  P

            We now know for sure that the pivot is in the correct place!
            array: [ 1  2  3  4  5  6 (7  8  9) 10 ]
                                          ^
                                          P

    --&gt; back in quicksort(array, 5, 9);

        Recursing...

        --&gt; quicksort(array, 5, 6);

            array: [ 1  2  3  4  5 (6  7) 8  9  10 ]
                                   ^^^^^^
            ---

            At the start of the function:
            array: [ 1  2  3  4  5 (6  7) 8  9  10 ]

            --&gt; median3(array, 5, 6);

                1. Swapping array[mid] and array[right-1] unconditionally
                array: [ 1  2  3  4  5 (6  7) 8  9  10 ]
                                        ^
                2. Swapping array[left] and array[right-1] if needed
                array: [ 1  2  3  4  5 (6  7) 8  9  10 ]
                                        ^
                3. Swapping array[left] and array[right] if needed
                array: [ 1  2  3  4  5 (6  7) 8  9  10 ]
                                        ^  ^
                4. Swapping array[right-1] and array[right] if needed
                array: [ 1  2  3  4  5 (6  7) 8  9  10 ]
                                        ^  ^
            --&gt; partition(array, 6, 5);

                start &gt; end, so nothing to do here!

        --&gt; back in quicksort(array, 5, 6);

            Recursing...

            --&gt; quicksort(array, 5, 5);

                array: [ 1  2  3  4  5 (6) 7  8  9  10 ]
                                       ^^^
                ---

                left &gt;= right, so nothing to do here!

        --&gt; back in quicksort(array, 5, 6);

            --&gt; quicksort(array, 7, 6);

                array: [ 1  2  3  4  5  6  7)(8  9  10 ]

                ---

                left &gt;= right, so nothing to do here!

        --&gt; back in quicksort(array, 5, 6);

    --&gt; back in quicksort(array, 5, 9);

        --&gt; quicksort(array, 8, 9);

            array: [ 1  2  3  4  5  6  7  8 (9  10)]
                                            ^^^^^^
            ---

            At the start of the function:
            array: [ 1  2  3  4  5  6  7  8 (9  10)]

            --&gt; median3(array, 8, 9);

                1. Swapping array[mid] and array[right-1] unconditionally
                array: [ 1  2  3  4  5  6  7  8 (9  10)]
                                                 ^
                2. Swapping array[left] and array[right-1] if needed
                array: [ 1  2  3  4  5  6  7  8 (9  10)]
                                                 ^
                3. Swapping array[left] and array[right] if needed
                array: [ 1  2  3  4  5  6  7  8 (9  10)]
                                                 ^  ^
                4. Swapping array[right-1] and array[right] if needed
                array: [ 1  2  3  4  5  6  7  8 (9  10)]
                                                 ^  ^
            --&gt; partition(array, 9, 8);

                start &gt; end, so nothing to do here!

        --&gt; back in quicksort(array, 8, 9);

            Recursing...

            --&gt; quicksort(array, 8, 8);

                array: [ 1  2  3  4  5  6  7  8 (9) 10 ]
                                                ^^^
                ---

                left &gt;= right, so nothing to do here!

        --&gt; back in quicksort(array, 8, 9);

            --&gt; quicksort(array, 10, 9);

                array: [ 1  2  3  4  5  6  7  8  9  10)]

                ---

                left &gt;= right, so nothing to do here!

        --&gt; back in quicksort(array, 8, 9);

    --&gt; back in quicksort(array, 5, 9);

--&gt; back in quicksort(array, 0, 9);

All done! Sorted array: [1  2  3  4  5  6  7  8  9  10]

</code></pre></div>  </div>

</aside>

<hr />

<!-- =============================================================== -->
<h3 id="both-sides-together">Both Sides Together!</h3>

<p>Given the following definition of a linked list,
implement merge sort on linked lists.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span> <span class="n">node</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
	<span class="n">Item</span> <span class="n">item</span><span class="p">;</span>
	<span class="n">node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<aside class="answer">
  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">node</span> <span class="o">*</span><span class="nf">sort_merge</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">list</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">node</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p2</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">*</span><span class="n">list1</span> <span class="o">=</span> <span class="n">sort_merge</span> <span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">*</span><span class="n">list2</span> <span class="o">=</span> <span class="n">sort_merge</span> <span class="p">(</span><span class="n">p2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">merge</span> <span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">node</span> <span class="o">*</span><span class="nf">merge</span> <span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">list1</span><span class="p">,</span> <span class="n">node</span> <span class="o">*</span><span class="n">list2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">node</span> <span class="o">*</span><span class="n">merged</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">node</span> <span class="o">*</span><span class="n">merged_end</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">list1</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">list2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Pick the list to pull the next item from.</span>
		<span class="n">node</span> <span class="o">**</span><span class="n">use</span>
			<span class="o">=</span> <span class="p">(</span><span class="n">list1</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">&lt;=</span> <span class="n">list2</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">)</span>
			<span class="o">?</span> <span class="o">&amp;</span><span class="n">list1</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">list2</span><span class="p">;</span>

		<span class="c1">// Append that node to the merged list.</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">merged</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">merged</span> <span class="o">=</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">merged_end</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
		<span class="n">merged_end</span> <span class="o">=</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
		<span class="o">*</span><span class="n">use</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">use</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// One of the lists must now be empty.</span>
	<span class="n">merged_end</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">list1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="n">list2</span> <span class="o">:</span> <span class="n">list1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">merged</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>
</aside>

<hr />

<!-- =============================================================== -->

<h3 id="macro-invertebrate">Macro-Invertebrate</h3>

<p>Sorting algorithms generally require a <em>swap</em> operation
which exchanges two values which are out of order.
The <code class="highlighter-rouge">swap()</code> operation used in the textbook
is implemented as a C macro:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define swap(a,b)  { Item tmp; tmp = a; a = b; b = tmp; }
</span></code></pre></div></div>

<p>Could this be re-implemented as a function?  Something like —</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span> <span class="p">(</span><span class="n">Item</span> <span class="n">i1</span><span class="p">,</span> <span class="n">Item</span> <span class="n">i2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Item</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If so, how would you use it?
If it would not be suitable, explain why not.</p>

<aside class="answer">
  <blockquote>
    <p>If <code class="highlighter-rouge">swap()</code> were implemented as the above function,
it would not work.
Parameters are pased <strong>by value</strong> in C;
parameters can be viewed as local variables
that have their values initialised
at the time the function is called.
With this perspective,
it is hopefully clear that the <code class="highlighter-rouge">swap()</code> function
will simply change the values of objects
that are local to the function,
and all effects will be lost
once the function exits.</p>

    <p>The macro works because
the swapping statements are inserted
into any function that uses the macro,
so the effects take place
within the environment of that function,
rather than within the local environment
of an invoked function.</p>
  </blockquote>
</aside>

<p>Consider the implementation of <code class="highlighter-rouge">swap()</code>
in the context of linked lists,
where <code class="highlighter-rouge">list</code>s are defined as:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="o">*</span><span class="n">List</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">list</span> <span class="n">list</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span> <span class="n">node</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span> <span class="n">Item</span> <span class="n">value</span><span class="p">;</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">list</span> <span class="p">{</span> <span class="kt">size_t</span> <span class="n">n_items</span><span class="p">;</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div>

<p>Would the macro above be suitable? If so, how would you use it?
If it would not be suitable, explain why not.</p>

<aside class="answer">
  <blockquote>
    <p>The macro definition could be used
to exchange the values stored in two list nodes; for example:</p>
  </blockquote>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">node</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">swap</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
</code></pre></div>  </div>

  <blockquote>
    <p>… which, after macro expansion, would become …</p>
  </blockquote>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span> <span class="n">Item</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="n">tmp</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
  <span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
  <span class="n">next</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>  </div>
</aside>

<p>Give a function to implement <code class="highlighter-rouge">swap()</code>
that <em>would</em> work for both arrays and linked lists.
Show examples of how your function
would be used for each structure.</p>

<aside class="answer">
  <blockquote>
    <p>A function to modify variables
from the calling function
would need to explicitly pass
references to the objects
in the calling function.
The following definition would be suitable:</p>
  </blockquote>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span> <span class="p">(</span><span class="n">Item</span> <span class="o">*</span><span class="n">i1</span><span class="p">,</span> <span class="n">Item</span> <span class="o">*</span><span class="n">i2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Item</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">i1</span><span class="p">;</span> <span class="o">*</span><span class="n">i1</span> <span class="o">=</span> <span class="o">*</span><span class="n">i2</span><span class="p">;</span> <span class="o">*</span><span class="n">i2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <blockquote>
    <p>And you would use it as:</p>
  </blockquote>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Item</span> <span class="n">a</span><span class="p">[...];</span>
<span class="c1">// ...</span>
<span class="n">swap</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</code></pre></div>  </div>

  <blockquote>
    <p>… or …</p>
  </blockquote>

  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">node</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">swap</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">));</span>
</code></pre></div>  </div>

</aside>

<hr />

<!-- =============================================================== -->
<h3 id="the-sentinel">The Sentinel</h3>

<p>Early in the course,
we discussed an alternate representation of linked lists,
where to indicate the end of the list,
we used a well-known “empty” node,
and not <code class="highlighter-rouge">NULL</code>.</p>

<p>We can use a similar approach for trees:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">btree_node</span> <span class="n">btree_node</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">btree_node</span> <span class="p">{</span>
	<span class="n">Item</span> <span class="n">item</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">btree_node</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">btree_node</span> <span class="o">*</span><span class="n">EMPTY_TREE</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">make_empty_tree</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">EMPTY_TREE</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">EMPTY_TREE</span> <span class="o">=</span> <span class="n">btree_node_new</span> <span class="p">(</span><span class="n">ItemNULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Given this tree
(for which this picture does not show
the links to the empty tree nodes),
what are the values of the following expressions?</p>

<!-- figure -->
<p><img style="margin: 24px auto" src="/~cs2521/19T0/week07/tree.png" />
<!-- /figure --></p>

<ul>
  <li><code class="highlighter-rouge">t0-&gt;size</code></li>
  <li><code class="highlighter-rouge">t2-&gt;size</code></li>
  <li><code class="highlighter-rouge">t3-&gt;size</code></li>
  <li><code class="highlighter-rouge">key (btree_nth (0)-&gt;item)</code></li>
  <li><code class="highlighter-rouge">key (btree_nth (3)-&gt;item)</code></li>
</ul>

<aside class="answer">
  <blockquote>
    <ul>
      <li><code class="highlighter-rouge">t0-&gt;size</code>: 11</li>
      <li><code class="highlighter-rouge">t2-&gt;size</code>: 3</li>
      <li><code class="highlighter-rouge">t3-&gt;size</code>: 1</li>
      <li><code class="highlighter-rouge">key (btree_nth (0)-&gt;item)</code>: A</li>
      <li><code class="highlighter-rouge">key (btree_nth (3)-&gt;item)</code>: F</li>
    </ul>
  </blockquote>
</aside>

<p>The <code class="highlighter-rouge">btree_nth</code> function picks, unsurprisingly,
the <script type="math/tex">n</script>th item out of a binary tree.
Here’s a recursive implementation:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">btree_node</span> <span class="o">*</span><span class="nf">btree_nth</span> <span class="p">(</span><span class="n">btree_node</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="n">EMPTY_TREE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">EMPTY_TREE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">tree</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">btree_nth</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">btree_nth</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Implement a non-recursive version.</p>

<aside class="answer">
  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">btree_node</span> <span class="o">*</span><span class="nf">btree_nth</span> <span class="p">(</span><span class="n">btree_node</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">node</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">tree</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">EMPTY_TREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">EMPTY_TREE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>  </div>
</aside>



</main>

  </main>

  <footer class="mt-3 py-3 text-center no-print bg-dark">
  <p class="text-muted">
    <strong>COMP2521 19T0: Data Structures and Algorithms</strong>
    is brought to you by <br />
    the <a href="https://www.cse.unsw.edu.au/">School of Computer Science and Engineering</a>
    at the <a href="https://www.unsw.edu.au/">University of New South Wales</a>, Sydney.<br />
    For all enquiries, please email the class account at
    <a href="mailto:cs2521@cse.unsw.edu.au">cs2521@cse.unsw.edu.au</a><br />

    <small>CRICOS Provider 00098G</small>
  </p>
</footer>

  <script type="text/javascript" async="1"
  src="https://code.jquery.com/jquery-3.1.1.slim.min.js"
  integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
<script type="text/javascript" async="1"
  src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js"
  integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
<script type="text/javascript" async="1"
  src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js"
  integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
<script type="text/javascript" async="1"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"
  integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous"></script>

<script type="text/javascript">
  // Hide navigiation in iframe
  if (window.self !== window.top)
    document.body.classList.add("iframe");
</script>

</body>
</html>
